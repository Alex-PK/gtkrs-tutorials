<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Content Management System - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="./introduction.html"><strong>1.</strong> Introduction</a></li><li><a href="./chapter_01.html"><strong>2.</strong> Window With A Header Bar</a></li><li><a href="./chapter_02/index.html"><strong>3.</strong> Button Boxer</a></li><li><ul class="section"><li><a href="./chapter_02/objects.html"><strong>3.1.</strong> Boxes, Buttons, &amp; Labels</a></li><li><a href="./chapter_02/state.html"><strong>3.2.</strong> Maintaining External State</a></li><li><a href="./chapter_02/ui.html"><strong>3.3.</strong> Creating the UI Structure</a></li><li><a href="./chapter_02/programming.html"><strong>3.4.</strong> Programming the UI</a></li><li><a href="./chapter_02/review.html"><strong>3.5.</strong> Conclusion &amp; Review</a></li></ul></li><li><a href="./chapter_03/index.html"><strong>4.</strong> HTML Articler</a></li><li><ul class="section"><li><a href="./chapter_03/objects.html"><strong>4.1.</strong> Entries, Panes, Scrolled Windows, &amp; Text Views</a></li><li><a href="./chapter_03/horrorshow.html"><strong>4.2.</strong> Horrorshow HTML Templating</a></li><li><a href="./chapter_03/ui.html"><strong>4.3.</strong> Creating the UI Structure</a></li><li><a href="./chapter_03/programming.html"><strong>4.4.</strong> Programming the UI</a></li><li><a href="./chapter_03/review.html"><strong>4.5.</strong> Conclusion &amp; Review</a></li></ul></li><li><a href="./chapter_04/index.html"><strong>5.</strong> Simple Common Mark Editor</a></li><li><ul class="section"><li><a href="./chapter_04/objects.html"><strong>5.1.</strong> Source Views, Web Views, &amp; File Dialogs</a></li><li><a href="./chapter_04/mods.html"><strong>5.2.</strong> Setting Up Modules</a></li><li><a href="./chapter_04/misc.html"><strong>5.3.</strong> The ui/misc.rs Module</a></li><li><a href="./chapter_04/ui.html"><strong>5.4.</strong> Creating the UI Structure</a></li><li><a href="./chapter_04/state.html"><strong>5.5.</strong> Maintaining External State</a></li><li><a href="./chapter_04/programming.html"><strong>5.6.</strong> Connecting Events</a></li><li><a href="./chapter_04/markdown_to_html.html"><strong>5.7.</strong> Markdown to HTML</a></li><li><a href="./chapter_04/webviews.html"><strong>5.8.</strong> Updating WebViews</a></li><li><a href="./chapter_04/markdown_to_html.html"><strong>5.9.</strong> Markdown to HTML</a></li><li><a href="./chapter_04/file_choosers.html"><strong>5.10.</strong> File Chooser Dialogs</a></li><li><a href="./chapter_04/open_button.html"><strong>5.11.</strong> Programming the Open Button</a></li><li><a href="./chapter_04/save_buttons.html"><strong>5.12.</strong> Programming the Save Buttons</a></li><li><a href="./chapter_04/keys.html"><strong>5.13.</strong> Binding Keys</a></li><li><a href="./chapter_04/review.html"><strong>5.14.</strong> Conclusion &amp; Review</a></li></ul></li><li><a href="./chapter_05/index.html"><strong>6.</strong> Advanced Common Mark Editor</a></li><li><ul class="section"><li><a href="./chapter_05/objects.html"><strong>6.1.</strong> Menu Buttons, Notebooks, &amp; Stacks</a></li></ul></li><li><a href="./chapter_06/index.html"><strong>7.</strong> Content Management System</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="print.html#introduction--tips" id="introduction--tips"><h1>Introduction &amp; Tips</h1></a>
<p>This unofficial GTK Rust tutorial series will focus on documenting important GTK features,
demonstrating how they are used in practice, and displaying some Rusty software techniques
along the way, as we explore what GTK GUI development in Rust is like.</p>
<blockquote>
<p>This tutorial is a very early WIP, and is subject to make structural changes in the coming
weeks, until I am happy with the state of the documentation, and my own writing. If there
are any issues, please send them to my <a href="mailto:mmstickman@gmail.com">email</a>, and I will
quickly address them. The GTK API is rather extensive, so it may take a while to flesh this
out properly.</p>
</blockquote>
<a class="header" href="print.html#obtaining-the-gtk-documentation" id="obtaining-the-gtk-documentation"><h2>Obtaining the GTK documentation</h2></a>
<p>The first thing you should do is to specify the GTK features you need. The max supported
version at this time is <strong>v3_22</strong>, which looks like so in your <strong>Cargo.toml</strong> file.</p>
<pre><code class="language-toml">gtk = { version = &quot;0.2&quot;, features = [&quot;v3_22&quot;] }
</code></pre>
<p>Then you can obtain offline documentation via running the following in the terminal, within
the root directory of your Cargo project:</p>
<pre><code class="language-sh">cargo doc
</code></pre>
<p>Which will compile the documentation into <strong>target/doc/gtk/index.html</strong>.</p>
<a class="header" href="print.html#tips-regarding-navigating-the-gtk-rust-api" id="tips-regarding-navigating-the-gtk-rust-api"><h2>Tips Regarding Navigating the GTK Rust API</h2></a>
<p><img src="images/api-diagram.png" /></p>
<p>The API for GTK in Rust is not as you might expect from other Rusty APIs, and so it may seem
that there is a lot of missing functionality in the generated documentaion. Each GTK object
contains an associated <strong>ObjectExt</strong> trait, such as <strong>ButtonExt</strong>.</p>
<p><img src="images/traitext.png" /></p>
<p>They also gain access to a number of other shared traits through the <strong>IsA&lt;T&gt;</strong> wrappers,
such as <strong>IsA&lt;Container&gt;</strong>, and <strong>IsA&lt;Widget&gt;</strong>. So if you want to know all of the methods
that are available for an object, you will need to also visit the associated traits for each of
those <strong>IsA&lt;T&gt;</strong> types that are implemented, such as <strong>WidgetExt</strong>.</p>
<p><img src="images/isawrapper.png" /></p>
<a class="header" href="print.html#gtk-objects-dont-require-mutability" id="gtk-objects-dont-require-mutability"><h2>GTK Objects Don't Require Mutability</h2></a>
<p><img src="images/rust_vs_gtk.png" /></p>
<p>GTK objects have their own mechanisms of reference counting, and are designed so that
you don't require ownersip or mutable access to modify them. This simplifies things greatly,
as you will only have to worry about borrowing and ownership with native Rust types. The only
thing that you need to be aware of is that you will need to increment reference counters when
passing GTK objects into closures to program your UI, which is done by cloning the object.</p>
<a class="header" href="print.html#window-with-a-header-bar" id="window-with-a-header-bar"><h1>Window With A Header Bar</h1></a>
<p><img src="images/headerbar.png" /></p>
<blockquote>
<p>The source code for this chapter can be found <a href="https://github.com/mmstick/gtkrs-tutorials/tree/master/demos/chapter_01">here</a>.</p>
</blockquote>
<p>In this chapter, we will create a simple GTK application that features a header bar. This will
serve as an introduction to the basics of creating a GTK application data structure to contain
the widgets that you will later program, as well as spawning a GTK window and running your
application.</p>
<blockquote>
<p>Before continuing, do ensure that you have added the <strong>gtk</strong> crate to your <strong>Cargo.toml</strong> file,
and additionally have specified at least <code>v3_14</code> as a feature to enable with the <strong>gtk</strong> crate.</p>
</blockquote>
<a class="header" href="print.html#creating-the-gtk-application-structures" id="creating-the-gtk-application-structures"><h2>Creating the GTK Application Structures</h2></a>
<p>The following diagram lays out how we will construct our GTK application data structure. One does
not have to follow this diagram to achieve the same result, but structuring your UI struct into a
hierarchy of partitions can be helpful to the mind.</p>
<p><img src="images/ch1_diagram.png" /></p>
<p>As we can see, we will need to create a structure that has a <strong>GtkWindow</strong> and a <strong>Header</strong>.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
extern crate gtk;
use gtk::*;
use std::process;

pub struct App {
    pub window: Window,
    pub header: Header,
}

#}</code></pre></pre>
<p>The <strong>Header</strong> is another structure that we will create, which will contain the <strong>GtkHeaderbar</strong> and
all of the widgets within that header bar.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
pub struct Header {
    pub container: HeaderBar
}

#}</code></pre></pre>
<a class="header" href="print.html#creating-the-ui-with-rust" id="creating-the-ui-with-rust"><h2>Creating the UI with Rust</h2></a>
<p>Next is to generate our UI with Rust, and store it in the newly-defined structures.</p>
<p>First is the <strong>App</strong> structure, which will be contain the overall structure of our UI in a
well-defined hierarchy of data structures and associated data. The following code example
provides in-line comments to describe each of the methods that are being used to configure it.</p>
<p>We will be creating the <strong>GtkWindow</strong> that we will attach every UI element to, the <strong>Header</strong>
structure that will contain our <strong>GtkHeaderBar</strong>, and programming the exit function within the
window. It's also important that we set a title for the window, the <strong>wmclass</strong> which will be
seen by window managers, and setting the icon to display within the window manager via the
<code>Window::set_default_icon_name()</code> function.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
impl App {
    fn new() -&gt; App {
        // Create a new top level window.
        let window = Window::new(WindowType::Toplevel);
        // Create a the headerbar and it's associated content.
        let header = Header::new();

        // Set the headerbar as the title bar widget.
        window.set_titlebar(&amp;header.container);
        // Set the title of the window.
        window.set_title(&quot;App Name&quot;);
        // Set the window manager class.
        window.set_wmclass(&quot;app-name&quot;, &quot;App name&quot;);
        // The icon the app will display.
        Window::set_default_icon_name(&quot;iconname&quot;);

        // Programs what to do when the exit button is used.
        window.connect_delete_event(move |_, _| {
            main_quit();
            Inhibit(false)
        });

        // Return our main application state
        App { window, header }
    }
}

#}</code></pre></pre>
<p>And then there is our <strong>Header</strong> structure, which for now, will only contain the <strong>GtkHeaderBar</strong>.
It is important to set the title of this header bar, if you want a title to be displayed, and to
also enable window controls on it, as this is disabled by default.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
impl Header {
    fn new() -&gt; Header {
        // Creates the main header bar container widget.
        let container = HeaderBar::new();

        // Sets the text to display in the title section of the header bar.
        container.set_title(&quot;App Name&quot;);
        // Enable the window controls within this headerbar.
        container.set_show_close_button(true);

        // Returns the header and all of it's state
        Header { container }
    }
}

#}</code></pre></pre>
<a class="header" href="print.html#initializing-and-launching-the-application" id="initializing-and-launching-the-application"><h2>Initializing and Launching the Application</h2></a>
<p>Now that we are ready, we simply need to initialize GTK, create our GTK application structure,
show all of the widgets within that structure, and start the GTK main event loop.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // Initialize GTK before proceeding.
    if gtk::init().is_err() {
        eprintln!(&quot;failed to initialize GTK Application&quot;);
        process::exit(1);
    }

    // Initialize the UI's initial state
    let app = App::new();

    // Make all the widgets within the UI visible.
    app.window.show_all();

    // Start the GTK main event loop
    gtk::main();
}
</code></pre></pre>
<p>Once the main thread has entered the event loop, it will poll across each of the widgets for
actions that have been triggered, such as the <code>connect_delete_event()</code> method that we used
above to program the exit button to exit the program.</p>
<a class="header" href="print.html#the-result" id="the-result"><h2>The Result</h2></a>
<p>With all of this complete, you should now have a program up and running that looks like so.</p>
<p><img src="images/headerbar.png" /></p>
<a class="header" href="print.html#button-boxer" id="button-boxer"><h1>Button Boxer</h1></a>
<p><img src="images/ch02_complete.png" /></p>
<blockquote>
<p>The source code for this chapter can be found <a href="https://github.com/mmstick/gtkrs-tutorials/tree/master/demos/chapter_02">here</a>.</p>
</blockquote>
<p>This section will give a look into how to structure your UI with boxes, manipulate labels,
and programming clicked buttons with closures. By the end, you will also have an understanding
of how to add children to a header bar, add style classes to buttons, manage application state
via <strong>Arc</strong>'d atomic components, and align widgets within a container.</p>
<blockquote>
<p>Recall that each GTK object that you obtain from the <strong>gtk</strong> crates are wrapped so that you
need not worry about Rust borrowing rules. GTK objects are reference-counted, so when you need
to share a GTK object across multiple closures, you can do so by simply cloning a new
reference.</p>
</blockquote>
<a class="header" href="print.html#prerequisites" id="prerequisites"><h2>Prerequisites</h2></a>
<p>It is generally assumed that you have an understanding of atomics and atomic reference
counters (<strong>Arc</strong>) before continuing with this tutorial. In order to share state across multiple
programmable closures, or even multiple threads, it is vital to take advantage of these concepts.
See the <strong>std::sync</strong> and <strong>std::sync::atomic</strong> modules to learn about them beforehand. You can
also check out <a href="https://assets.bitbashing.io/papers/lockless.pdf">this paper on lockless concurrency</a>.</p>
<a class="header" href="print.html#boxes-buttons--labels" id="boxes-buttons--labels"><h1>Boxes, Buttons, &amp; Labels</h1></a>
<p>The purpose of this section is to give an explanation of the objects that are about to used,
before demonstrating how they are used in practice in subsequent sections.</p>
<a class="header" href="print.html#gtkbox" id="gtkbox"><h2>GtkBox</h2></a>
<p>A <strong>GtkBox</strong> is effectively a UI equivalent of vectors in Rust, and must be defined with an
<strong>Orientation</strong>, which defines whether elements should be aligned from left to right, or
top to bottom. For those who have experience with modern HTML5/CSS3 designs, a <strong>GtkBox</strong>
is equivalent to a flex box -- they expand to cover the full space, and widgets contained
within are expanded according to rules applied when packing the children.</p>
<a class="header" href="print.html#creating-boxes" id="creating-boxes"><h3>Creating Boxes</h3></a>
<p>In the following example, a horizontal and vertical box will be created with 0 padding between
children contained within the box. Once you have created your box, you can assign widgets to
the box using the <code>pack_*</code> methods.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let padding_between_children = 0;
let horizontal_box = Box::new(Orientation::Horizontal, padding_between_children);
let vertical_box = Box::new(Orientation::Vertical, padding_between_children);

#}</code></pre></pre>
<a class="header" href="print.html#packing-boxes" id="packing-boxes"><h3>Packing Boxes</h3></a>
<p>You may notice that the <code>pack_*</code> methods take a lot of miscellanious parameters. The first
parameter should be a reference to the widget that you are adding to the container. The
second and third parameters define the expand a fill parameters respectively. The final
parameter then defines how many units of space should be between children in the box.</p>
<blockquote>
<p>To further elaborate on the expand and fill parameters, expand defines whether the
given widget should attempt to use all of the extra space that it can. Each widget that has
the expand parameter set will equally share that extra space. Meanwhile, fill defines whether
the extra spaced should actually have that widget fill to cover that extra space, or should
merely use that extra space as padding.</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
health_info.pack_start(&amp;health_label, false, false, 5);
health_info.pack_start(&amp;health, true, true, 5);

#}</code></pre></pre>
<a class="header" href="print.html#gtklabel" id="gtklabel"><h2>GtkLabel</h2></a>
<p>A <strong>GtkLabel</strong> is simply a widget that consists solely of text. It's fairly self-explanatory
as a result. All you truly need to memorize is how to create a label, and change a label.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let information_label = Label::new(&quot;Specific Information: &quot;);
let value = Label::new(&quot;Linux&quot;);
value.set_label(&quot;Redox&quot;);

let horizontal_box = Box::new(Orientation::Horizontal, 5);
horizontal_box.pack_start(&amp;information_label, false, false, 0);
horizontal_box.pack_start(&amp;value, true, false, 0);

#}</code></pre></pre>
<a class="header" href="print.html#gtkbutton" id="gtkbutton"><h2>GtkButton</h2></a>
<a class="header" href="print.html#creating-buttons" id="creating-buttons"><h3>Creating Buttons</h3></a>
<p>A <strong>GtkButton</strong> is a simple button that contains a text label, and/or an image to represent
the action that is to be performed upon clicking that button.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let text_button = Button::new_with_label(&quot;Ok&quot;);
let image_button = Button::new_from_icon_name(&quot;icon-name&quot;, 32);

#}</code></pre></pre>
<a class="header" href="print.html#styling-buttons" id="styling-buttons"><h3>Styling Buttons</h3></a>
<p>Widgets within GTK can be styled so that they stand out from other widgets in the UI. Buttons
in particularl support two style classes: destructive-action, and suggested-action. If you have
a critical button that needs to stand out in the UI, you can set them like so:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
// Add the corresponding style classes to those buttons.
delete_button.get_style_context().map(|c| c.add_class(&quot;destructive-action&quot;));
new_button.get_style_context().map(|c| c.add_class(&quot;suggested-action&quot;));

#}</code></pre></pre>
<p>Each <strong>GtkWidget</strong> provides a <strong>get_style_context()</strong> method, which returns an
<strong>Option<StyleContext></strong>, which thereby provides an <strong>add_class()</strong> method, which is then used
to set style classes. Got it? Good. The most important classes to know for buttons are the
<code>destructive-action</code> and <code>suggested-action</code> buttons. Typically, a destructive action sets the
button to a red color, while the suggested action uses a blue color. The actual color will depend
upon which GTK theme that the user is using, though.</p>
<a class="header" href="print.html#maintaining-external-state" id="maintaining-external-state"><h1>Maintaining External State</h1></a>
<p>In this chapter, we are going to have some state that we will manipulate with the UI. We
therefore need a means of storing and loading values from that state. The program that
we are going to create has a single component: a health value.</p>
<p>As it turns out, we can take advantage of atomic primitives directly, such as
<strong>AtomicUsize</strong>, to store this value for sharing across multiple immutable closures. This
atomic value can be manipulated without requiring mutable access to the inner value. So this
can be passed around through an immutable borrow, and modified while being immutably borrowed
at multiple locations.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
pub struct HealthComponent(AtomicUsize);

#}</code></pre></pre>
<p>While we are at it, we can go ahead and abstract some logic to this component by implementing
some useful methods for initializing the health, subtracting health, and healing health.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
impl HealthComponent {
    fn new(initial: usize) -&gt; HealthComponent { HealthComponent(AtomicUsize::new(initial)) }

    fn get_health(&amp;self) -&gt; usize { self.0.load(Ordering::SeqCst) }

    fn subtract(&amp;self, value: usize) -&gt; usize {
        let current = self.0.load(Ordering::SeqCst);
        let new = if current &lt; value { 0 } else { current - value };
        self.0.store(new, Ordering::SeqCst);
        new
    }

    fn heal(&amp;self, value: usize) -&gt; usize {
        let original = self.0.fetch_add(value, Ordering::SeqCst);
        original + value
    }
}

#}</code></pre></pre>
<a class="header" href="print.html#creating-the-ui-structure" id="creating-the-ui-structure"><h1>Creating the UI Structure</h1></a>
<p>Using the previous chapter's structure as a template, we can expand that to include the new UI
elements that we are going to use within our program. It is important to note that you only
need to store elements that you are going to later program after the UI is constructed.</p>
<p>In this program, we are going to add two <strong>GtkButtons</strong> to the header bar, along with using
a vertical and horizontal <strong>GtkBox</strong> with some labels to display information about our
application's state. The following chart is the new diagram of our structure.</p>
<p><img src="images/ch02_diagram.png" /></p>
<p>Which translates to the following Rust data structures:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
pub struct App {
    pub window:  Window,
    pub header:  Header,
    pub content: Content,
}

pub struct Header {
    pub container: HeaderBar,
    pub hit:       Button,
    pub heal:      Button,
}

pub struct Content {
    pub container: Box,
    pub health:    Label,
    pub message:   Label,
}

#}</code></pre></pre>
<a class="header" href="print.html#creating-the-app-structure" id="creating-the-app-structure"><h2>Creating the App Structure</h2></a>
<p>Starting with our <strong>App</strong> structure, we will do as the last tutorial, but our <strong>new()</strong> metheod
shall take a <strong>&amp;HealthComponent</strong> as an input to set the initial value in the UI, later on
down the road within our <strong>Content</strong> structure. One will note that we have added a new
<strong>content</strong> variable of type <strong>Context</strong>, which takes that health reference.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
impl App {
    fn new(health: &amp;HealthComponent) -&gt; App {
        // Create a new top level window.
        let window = Window::new(WindowType::Toplevel);
        // Create a the headerbar and it's associated content.
        let header = Header::new();
        // Contains the content within the window.
        let content = Content::new(health);

        // Set the headerbar as the title bar widget.
        window.set_titlebar(&amp;header.container);
        // Set the title of the window.
        window.set_title(&quot;App Name&quot;);
        // Set the window manager class.
        window.set_wmclass(&quot;app-name&quot;, &quot;App name&quot;);
        // The icon the app will display.
        Window::set_default_icon_name(&quot;iconname&quot;);
        // Add the content box into the window.
        window.add(&amp;content.container);

        // Programs what to do when the exit button is used.
        window.connect_delete_event(move |_, _| {
            main_quit();
            Inhibit(false)
        });

        // Return our main application state
        App { window, header, content }
    }
}

#}</code></pre></pre>
<a class="header" href="print.html#creating-the-header" id="creating-the-header"><h2>Creating the Header</h2></a>
<p>Then we shall also implement the same method for our header, which shall now contain two
<strong>GtkButtons</strong> -- the hit and heal buttons. Also take note that we are assigning some style
classes to these buttons, to give them a more informative visual flair.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
impl Header {
    fn new() -&gt; Header {
        // Creates the main header bar container widget.
        let container = HeaderBar::new();

        // Sets the text to display in the title section of the header bar.
        container.set_title(&quot;App Name&quot;);
        // Enable the window controls within this headerbar.
        container.set_show_close_button(true);

        // Create the hit and heal buttons.
        let hit = Button::new_with_label(&quot;Hit&quot;);
        let heal = Button::new_with_label(&quot;Heal&quot;);

        // Add the corresponding style classes to those buttons.
        hit.get_style_context().map(|c| c.add_class(&quot;destructive-action&quot;));
        heal.get_style_context().map(|c| c.add_class(&quot;suggested-action&quot;));

        // THen add them to the header bar.
        container.pack_start(&amp;hit);
        container.pack_end(&amp;heal);

        // Returns the header and all of it's state
        Header { container, hit, heal }
    }
}

#}</code></pre></pre>
<a class="header" href="print.html#creating-the-content" id="creating-the-content"><h2>Creating the Content</h2></a>
<p>Now it's time to create the content for our window. You will almost reach for <strong>GtkBoxes</strong> when
constructing your UI, creating your interface with a tree-like diagram. These boxes, when initialized,
must be specified as either <strong>Horizontal</strong> or <strong>Vertical</strong> orientations.</p>
<p>You will amost certainly reach for <strong>GtkBoxes</strong>
for configuring your UI. These can be created with either a <strong>Horizontal</strong> or <strong>Vertical</strong>
alignment. These boxes are where you will add all of your widgets, where they will be stacked
according to the alignment of the box they are attached to.</p>
<p>We shall create a vertical box that will contain two children: a vertical <strong>GtkBox</strong> that contains
a label and a value, followed by a simple <strong>GtkLabel</strong> underneath.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
impl Content {
    fn new(health: &amp;HealthComponent) -&gt; Content {
        // Create a vertical box to store all of it's inner children vertically.
        let container = Box::new(Orientation::Vertical, 0);

        // The health info will be contained within a horizontal box within the vertical box.
        let health_info = Box::new(Orientation::Horizontal, 0);
        let health_label = Label::new(&quot;Current Health:&quot;);
        let health = Label::new(health.get_health().to_string().as_str());

        // Set the horizontal alignments of each of our objects.
        health_info.set_halign(Align::Center);
        health_label.set_halign(Align::Start);
        health.set_halign(Align::Start);


        // Add the health info box's children
        health_info.pack_start(&amp;health_label, false, false, 5);
        health_info.pack_start(&amp;health, true, true, 5);

        // Create a message label that will later be modified by the application, upon
        // performing a hit or heal action.
        let message = Label::new(&quot;Hello&quot;);

        // Add everything to our vertical box
        container.pack_start(&amp;health_info, true, false, 0);
        container.pack_start(&amp;Separator::new(Orientation::Horizontal), false, false, 0);
        container.pack_start(&amp;message, true, false, 0);

        Content { container, health, message }
    }
}

#}</code></pre></pre>
<a class="header" href="print.html#set-alignments" id="set-alignments"><h3>Set Alignments</h3></a>
<p>You may have noticed that the above code is setting horizontal alignments. Widgets can optionally
be supplied an alignment enum to their <code>set_halign()</code> and <code>set_valign()</code> methods, which, as you
would guess, modifies the alignment of the child within the UI.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
// Set the horizontal alignments of each of our objects.
health_info.set_halign(Align::Center);
health_label.set_halign(Align::Start);
health.set_halign(Align::Start);

#}</code></pre></pre>
<a class="header" href="print.html#programming-the-ui" id="programming-the-ui"><h1>Programming the UI</h1></a>
<p>At this point, we can now wire everything together in the main thread. First we will set the
default value (health value) for the state of the program. That value will be used to set
the initial state of the GTK application structure. Then we shall program the hit and heal
buttons, which shall change values in the content area of main window.</p>
<a class="header" href="print.html#before-we-start" id="before-we-start"><h2>Before We Start</h2></a>
<p>We are going to have some predefined strings utilized based on what action was performed, and
certain conditions of the <strong>HealthComponents</strong> value. To do this, we will have a <strong>MESSAGES</strong>
array that we will access via a <strong>u8</strong>-sized enum, which will be used to get indexes into the
array.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
/// Predefined messages that will be used by the UI upon certain conditions.
const MESSAGES: [&amp;str; 3] = [&quot;Ouch! You hit me!&quot;, &quot;...&quot;, &quot;Thanks!&quot;];

#[repr(u8)]
// An enum, represented as a u8, that is used as an index into the `MESSAGES` array.
enum Message { Hit, Dead, Heal }

#}</code></pre></pre>
<p>For those not yet versed in Rust, the <code>#[repr(u8)]</code> attribute defines that the following item
should be represented as a <strong>u8</strong> value in memory. By default, enum variants start counting from
zero, so <strong>Hit</strong> is <code>0</code>, whereas <strong>Heal</strong> is <code>2</code>. If you want to make this explicit, you can also
write this as so:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
#[repr(u8)]
enum Message { Hit = 0, Dead = 1, Heal = 2 }

#}</code></pre></pre>
<a class="header" href="print.html#initializing-the-health-component--application-structure" id="initializing-the-health-component--application-structure"><h2>Initializing the Health Component &amp; Application Structure</h2></a>
<p>After initializing GTK, we will create our health component, which will be wrapped within an
atomic reference-counted pointer (<strong>Arc</strong>). If we remember from previous code, the inner value
is actually an <strong>AtomicUsize</strong>, which serves as our health counter. This value will be shared
among multiple closures, hence the requirement for the reference counter.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let health = Arc::new(HealthComponent::new(10));

#}</code></pre></pre>
<p>Using this value, we will create our application's UI structure. Note that <code>&amp;health</code> is
automatically referenced as an <strong>&amp;HealthComponent</strong>, even though it's wrapped within an <strong>Arc</strong>.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let app = App::new(&amp;health);

#}</code></pre></pre>
<a class="header" href="print.html#programming-the-hit-button" id="programming-the-hit-button"><h2>Programming the Hit Button</h2></a>
<p>From here on, all we need to is to program our widgets, and this is where we will share both
our health component, and various other UI widgets across closures. Starting with the hit button,
we simply need to program what will happen when that button is clicked. The <strong>ButtonExt</strong> trait
provides a <strong>connect_clicked()</strong> method for precisely that.</p>
<blockquote>
<p>Note that widgets in GTK typically pass themselves through their closures, so if you need to
manipulate the calling widget, you can do so by using the assigned value passed through the
closure. We don't require this functionality, so we shall ignore the value.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
widget.connect_action(move |widget| {});

#}</code></pre></pre>
</blockquote>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
{
    // Program the Hit button to subtract health.
    let health = health.clone();
    let message = app.content.message.clone();
    let info = app.content.health.clone();
    app.header.hit.clone().connect_clicked(move |_| {
        let new_health = health.subtract(1);
        let action = if new_health == 0 { Message::Dead } else { Message::Hit };
        message.set_label(MESSAGES[action as usize]);
        info.set_label(new_health.to_string().as_str());
    });
}

#}</code></pre></pre>
<p>In the above, we create an anonymous scope so that we can self-contain our cloned references.
Each invocation of <strong>clone()</strong> will simply increment a reference counter, and enable these values
to be used again at a later time.</p>
<p>After subtracting from the health component, if the health is now <code>0</code>, we will return
<strong>Message::Dead</strong>, otherwise the message shall be <strong>MessageHit</strong>. Once we have this information,
it's just a matter of updated the labels with their new values.</p>
<a class="header" href="print.html#programming-the-heal-button" id="programming-the-heal-button"><h2>Programming the Heal Button</h2></a>
<p>This works almost identically, so we can effectively copy and paste the above code, and then
modify it to meet our needs for this action.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
{
    // Program the Heal button to restore health.
    let health = health.clone();
    let message = app.content.message.clone();
    let info = app.content.health.clone();
    app.header.heal.clone().connect_clicked(move |_| {
        let new_health = health.heal(5);
        message.set_label(MESSAGES[Message::Heal as usize]);
        info.set_label(new_health.to_string().as_str());
    });
}

#}</code></pre></pre>
<a class="header" href="print.html#altogether" id="altogether"><h2>Altogether</h2></a>
<p>After programming the UI, you can end the code by tacking on the following at the end:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
// Make all the widgets within the UI visible.
app.window.show_all();

// Start the GTK main event loop
gtk::main();

#}</code></pre></pre>
<p>And you should have your source code look as follows:</p>
<pre><pre class="playpen"><code class="language-rust">/// Predefined messages that will be used by the UI upon certain conditions.
const MESSAGES: [&amp;str; 3] = [&quot;Ouch! You hit me!&quot;, &quot;...&quot;, &quot;Thanks!&quot;];

#[repr(u8)]
// An enum, used as a u8, that is used as an index into the `MESSAGES` array.
enum Message { Hit, Dead, Heal }

fn main() {
    // Initialize GTK before proceeding.
    if gtk::init().is_err() {
        eprintln!(&quot;failed to initialize GTK Application&quot;);
        process::exit(1);
    }

    // Set the initial state of our health component. We use an `Arc` so that we can share
    // this value across multiple programmable closures.
    let health = Arc::new(HealthComponent::new(10));

    // Initialize the UI's initial state.
    let app = App::new(&amp;health);

    {
        // Program the Hit button to subtract health.
        let health = health.clone();
        let message = app.content.message.clone();
        let info = app.content.health.clone();
        app.header.hit.clone().connect_clicked(move |_| {
            let new_health = health.subtract(1);
            let action = if new_health == 0 { Message::Dead } else { Message::Hit };
            message.set_label(MESSAGES[action as usize]);
            info.set_label(new_health.to_string().as_str());
        });
    }

    {
        // Program the Heal button to restore health.
        let health = health.clone();
        let message = app.content.message.clone();
        let info = app.content.health.clone();
        app.header.heal.clone().connect_clicked(move |_| {
            let new_health = health.heal(5);
            message.set_label(MESSAGES[Message::Heal as usize]);
            info.set_label(new_health.to_string().as_str());
        });
    }

    // Make all the widgets within the UI visible.
    app.window.show_all();

    // Start the GTK main event loop
    gtk::main();
}
</code></pre></pre>
<a class="header" href="print.html#conclusion--review" id="conclusion--review"><h1>Conclusion &amp; Review</h1></a>
<p>If you click on the <strong>Hit</strong> button, the counter should decrement and the message should change.
Clicking on the <strong>Heal</strong> button should increment the counter and also change the message.After
running your program with <code>cargo run</code>, you should have a window that looks like so:</p>
<p><img src="images/ch02_complete.png"></p>
<p>At this point, you should have a decent understanding of how <strong>GtkBox</strong>, <strong>GtkButton</strong>, and
<strong>GtkLabel</strong> works. It may be a good idea to revisit the previons
<a href="./chapter_02_objects.md">GTK Objects Covered</a> section to review the specific details regarding
them.</p>
<a class="header" href="print.html#practice-challenges" id="practice-challenges"><h2>Practice Challenges</h2></a>
<a class="header" href="print.html#setting-inputs-w-buttons" id="setting-inputs-w-buttons"><h3>Setting Inputs w/ Buttons</h3></a>
<p>There isn't much that you can do with just buttons and labels. If you want a practice challenge,
try creating a program that displays a simple random math problem, and asks the user to use
buttons to set the value. If they get it correct, modify a label to tell the user that what they
entered was correct. This is an incredibly annoying interface design, so don't do this in the real
world!</p>
<a class="header" href="print.html#bonus-timed-answers" id="bonus-timed-answers"><h3>Bonus: Timed Answers</h3></a>
<p>Do the same as the above, but also take advantage of
<a href="https://docs.rs/gtk/0.2.0/gtk/fn.timeout_add.html">gtk::timeout_add()</a> to decrement
and update a timer label within the UI until the timer reaches zero.</p>
<a class="header" href="print.html#html-articler" id="html-articler"><h1>HTML Articler</h1></a>
<p><img src="images/ch03_complete.png" /></p>
<blockquote>
<p>The source code for this chapter can be found <a href="https://github.com/mmstick/gtkrs-tutorials/tree/master/demos/chapter_03">here</a>.</p>
</blockquote>
<p>In this chapter, you will begin to write useful software that takes advantage of text entries
and text views, to allow the user to enter data within various input fields, and to generate
an output from those inputs after clicking a button. In addition, you will also be exposed
to the '<strong>html!</strong>' macro within the <a href="https://docs.rs/horrorshow/">horrorshow crate</a>.
You will be writing a program that takes inputs on the left pane, and generates minified HTML
within the right text view.</p>
<blockquote>
<p>Note that there isn't any external state to worry about in this chapter, as there was in the
last. All of the state that we are concerned with is contained within the GTK objects that
we will be interacting with.</p>
</blockquote>
<a class="header" href="print.html#entries-panes-scrolled-windows--text-views" id="entries-panes-scrolled-windows--text-views"><h1>Entries, Panes, Scrolled Windows, &amp; Text Views</h1></a>
<a class="header" href="print.html#gtkpaned" id="gtkpaned"><h2>GtkPaned</h2></a>
<p>These are containers that may be oriented either vertically or horizontally, and feature two
resizeable children. These children are resized merely by clicking and dragging the divider
between them.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let container = Paned::new(Orientation::Horizontal);
let left_widget = ...;
let right_widget = ...;
container.pack1(&amp;left_widget, true, true);
container.pack2(&amp;right_widget, true, true);

#}</code></pre></pre>
<p>Within the pack methods above, the two <code>true</code> values designate whether the child can shrink,
and whether the child can be resized.</p>
<a class="header" href="print.html#gtkentry" id="gtkentry"><h2>GtkEntry</h2></a>
<p>Entries enable the UI to accept a line of text as input, which can be utilized by other widgets
to perform certain actions using that text as the input.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let entry = Entry::new();
entry.set_text(&quot;Some Text&quot;);
if let Some(text) = entry.get_text() {
    println!(&quot;{}&quot;, text);
}

#}</code></pre></pre>
<a class="header" href="print.html#gtktextview" id="gtktextview"><h2>GtkTextView</h2></a>
<p>Text views serve two purposes: the ability to display multiple lines of text within a text box,
and the ability to input multiple lines of text. These may be configured to be non-editable,
if editing a view is not desired. They also provide methods for controlling the word-wrapping
behavior. They aren't capable of handling formatted text, however, or useful as a code editor.
If you want text to be rendered in HTML, see <strong>GtkWebView</strong>; and if you want a code editor, see
<strong>GtkSourceView</strong>.</p>
<blockquote>
<p>Note that it is often times best to create and assign the <strong>GtkTextBuffer</strong> to your text view
manually, in order to get a handle to that buffer which you can store, and avoid some
indirection when programming your UI, and to get direct access to the text within.</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
// The buffer for the text view, with `None` as the parameter because we are
// not going to define any text tags for this buffer.
let text_buffer = TextBuffer::new(None);
// Then we shall assign the buffer to a new text view, which will automatically
// update itself as text is added or removed from the buffer.
let text_view = TextView::new_with_buffer(&amp;text_buffer);

#}</code></pre></pre>
<p>Getting text from a <strong>GtkTextBuffer</strong> is a little tricky, so here's an abstraction which you
can use to specify to grab the entire range of the buffer and return it as a <strong>String</strong>. As it
turns out, you may specify a specific range of text to obtain from this buffer.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
/// Obtain the entire text buffer's contents as a string.
fn get_buffer(buffer: &amp;TextBuffer) -&gt; Option&lt;String&gt; {
    let start = buffer.get_start_iter();
    let end = buffer.get_end_iter();
    buffer.get_text(&amp;start, &amp;end, true)
}

#}</code></pre></pre>
<a class="header" href="print.html#gtkscrolledwindow" id="gtkscrolledwindow"><h2>GtkScrolledWindow</h2></a>
<p>These are single-element boxes that feature a scrollable window within. It can be useful to combine
them with text views to enable text views to scroll. This is precisely what we are about to do
within this chapter.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let scrolled_window = ScrolledWindow::new(None, None);
scrolled_window.add(&amp;text_view);

#}</code></pre></pre>
<a class="header" href="print.html#horrorshow-html-templating" id="horrorshow-html-templating"><h1>Horrorshow HTML Templating</h1></a>
<p>Although not related to GTK development, the <a href="https://docs.rs/horrorshow/">horrorshow crate</a> provides
very useful macro-based HTML templating capabilities, which allows you to efficiently generate
an HTML string in memory using a DSL (domain-specific language) combined with Rust, which can
be invoked through usage of the <code>@</code> sigil.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
#[macro_use]
extern crate horrorshow;
use horrorshow::helper::doctype;

let title = &quot;Title&quot;;
let content = &quot;A string\nwith multiple\n\nlines&quot;;
let html_string = format!(
    &quot;{}&quot;,
    html!{
        : doctype::HTML,
        html {
            head {
                style { : &quot;#style { }&quot; }
            }
            body {
                h1(id=&quot;style&quot;) { : title }
                @ for line in content.lines().filter(|x| !x.is_empty()) {
                    p { : line }
                }
            }
        }
    }
);

#}</code></pre></pre>
<a class="header" href="print.html#creating-the-ui-structure-1" id="creating-the-ui-structure-1"><h1>Creating the UI Structure</h1></a>
<p><img src="images/ch03_complete.png" /></p>
<p>Using the first chapter as a template and expanding upon that, we shall design our UI according
to the vision of our UI, pictured above. The key widgets to take note of are the <strong>post</strong> button
in the header bar; and within our content window is a <strong>title</strong> entry, <strong>tags</strong> entry,
<strong>content</strong> text view, and a <strong>right_pane</strong> text view for displaying the output in HTML. As such,
our application's UI structure should look as so:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
pub struct App {
    pub window: Window,
    pub header: Header,
    pub content: Content,
}

pub struct Header {
    pub container: HeaderBar,
    pub post: Button
}

pub struct Content {
    pub container: Paned,
    pub title: Entry,
    pub tags: Entry,
    pub content: TextBuffer,
    pub right_pane: TextBuffer,
}

#}</code></pre></pre>
<p>Note that the container for our content will not be a <strong>GtkBox</strong>, but a <strong>GtkPaned</strong>. This will
enable the user to drag the divider between the panels to resize them as needed. In addition,
the <strong>content</strong> and <strong>right_pane</strong> fields are stored as <strong>GtkTextBuffers</strong>, instead of
<strong>GtkTextViews</strong>. This is because we are not going to be programming the views -- just accessing
the underlying text buffers that are associated with the views.</p>
<a class="header" href="print.html#app-implementation" id="app-implementation"><h2>App Implementation</h2></a>
<p>Something new that we will do here is to define the default size of the window, as we should
have a reasonable size for the user to interact with by default, without needing to resize
the window to get a good look at the contents within. We are also setting the title of this
application as 'HTML Articler'. Beyond that, this should be very similar for every application
you develop.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
impl App {
    fn new() -&gt; App {
        // Create a new top level window.
        let window = Window::new(WindowType::Toplevel);
        // Create a the headerbar and it's associated content.
        let header = Header::new();
        // Create the main content.
        let content = Content::new();

        // Set the headerbar as the title bar widget.
        window.set_titlebar(&amp;header.container);
        // Set the title of the window.
        window.set_title(&quot;HTML Articler&quot;);
        // Set the window manager class.
        window.set_wmclass(&quot;html-articler&quot;, &quot;HTML Articler&quot;);
        // The icon the app will display.
        Window::set_default_icon_name(&quot;iconname&quot;);
        // Set the default size of the window.
        window.set_default_size(800, 600);
        // Add the content to the window.
        window.add(&amp;content.container);

        // Programs what to do when the exit button is used.
        window.connect_delete_event(move |_, _| {
            main_quit();
            Inhibit(false)
        });

        // Return our main application state
        App { window, header, content }
    }
}

#}</code></pre></pre>
<a class="header" href="print.html#header-implementation" id="header-implementation"><h2>Header Implementation</h2></a>
<p>Our header bar will simply have a button with a &quot;Post&quot; label, which is given a 'suggested-action'
as a style class, and packed at the end of the bar. The title of the bar should also be set to
the name of our application.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
impl Header {
    fn new() -&gt; Header {
        // Creates the main header bar container widget.
        let container = HeaderBar::new();

        // Sets the text to display in the title section of the header bar.
        container.set_title(&quot;HTML Articler&quot;);
        // Enable the window controls within this headerbar.
        container.set_show_close_button(true);

        // Create a button that will post the HTML article.
        let post = Button::new_with_label(&quot;Post&quot;);
        post.get_style_context().map(|x| x.add_class(&quot;suggested-action&quot;));

        container.pack_end(&amp;post);

        // Returns the header and all of it's state
        Header { container, post }
    }
}

#}</code></pre></pre>
<a class="header" href="print.html#content-implementation" id="content-implementation"><h2>Content Implementation</h2></a>
<p>This is where we will spend most of our time for this application. First we create a
<strong>GtkPaned</strong> container that will hold our resizeable left and right panes. Our right pane
will be a <strong>GtkTextView</strong>, whereas the left pane is a vertical <strong>GtkBox</strong>. Note that we
are interested in getting direct access to that text view's buffer, so we will also
initialize that before creating the view. The left pane's box will have a padding of <code>5</code>
between children, just so that they aren't smushed together.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
// The main container will hold a left and right pane. The left pane is for user input,
// whereas the right pane is for the generated output.
let container = Paned::new(Orientation::Horizontal);
let left_pane = Box::new(Orientation::Vertical, 5);
let right_pane = TextBuffer::new(None);
let right_pane_view = TextView::new_with_buffer(&amp;right_pane);

#}</code></pre></pre>
<p>Then comes creating the <strong>title</strong> and <strong>tags</strong> entries, as well as the <strong>content</strong> view that
we will use to construct the left pane.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
// The left pane will consist of a title entry, tags entry, and content text view.
let title = Entry::new();
let tags = Entry::new();
let content = TextBuffer::new(None);
let content_view = TextView::new_with_buffer(&amp;content);

#}</code></pre></pre>
<p>Note that we will also be storing a centered label above the <strong>content</strong> text view, followed
by adding some placeholder text within the entries, and tooltips to display when a mouse is
hovering over the entries.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
// The label that we will display above the content box to describe it.
let content_label = Label::new(&quot;Content&quot;);
content_label.set_halign(Align::Center);

// Set placeholders within the entries to hint the user of the contents to enter.
title.set_placeholder_text(&quot;Insert Title&quot;);
tags.set_placeholder_text(&quot;Insert Colon-Delimited Tags&quot;);

// Additionally set tooltips on the entries. Note that you may use either text or markup.
title.set_tooltip_text(&quot;Insert the title of article here&quot;);
tags.set_tooltip_markup(&quot;&lt;b&gt;tag_one&lt;/b&gt;:&lt;b&gt;tag two&lt;/b&gt;:&lt;b&gt; tag three&lt;/b&gt;&quot;);

#}</code></pre></pre>
<p>Then ensuring that the right pane's text view is not editable, and both of the text views
have their text wrapped by words.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
// The right pane should disallow editing; and both editors should wrap by word.
right_pane_view.set_editable(false);
right_pane_view.set_wrap_mode(WrapMode::Word);
content_view.set_wrap_mode(WrapMode::Word);

#}</code></pre></pre>
<p>Now we just need to wrap the text views within some <strong>GtkScrolledWindows</strong> to enable the user
to scroll through the text, in the event that there is enough text that it cannot be displayed
all at once within the widget.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
// Wrap the text views within scrolled windows, so that they can scroll.
let content_scroller = ScrolledWindow::new(None, None);
let right_pane_scrolled = ScrolledWindow::new(None, None);
content_scroller.add(&amp;content_view);
right_pane_scrolled.add(&amp;right_pane_view);

#}</code></pre></pre>
<p>And to make our UI look better, we can apply some borders and margins accordingly.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
// Paddin' Widgets
left_pane.set_border_width(5);
right_pane_view.set_left_margin(5);
right_pane_view.set_right_margin(5);
right_pane_view.set_top_margin(5);
right_pane_view.set_bottom_margin(5);
content_view.set_left_margin(5);
content_view.set_right_margin(5);
content_view.set_top_margin(5);
content_view.set_bottom_margin(5);

#}</code></pre></pre>
<p>And all that remains is to pack our widgets into their panes and return a <strong>Content</strong> structure.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
// First add everything to the left pane box.
left_pane.pack_start(&amp;title, false, true, 0);
left_pane.pack_start(&amp;tags, false, true, 0);
left_pane.pack_start(&amp;content_label, false, false, 0);
left_pane.pack_start(&amp;content_scroller, true, true, 0);

// Then add the left and right panes into the container
container.pack1(&amp;left_pane, true, true);
container.pack2(&amp;right_pane_scrolled, true, true);

Content { container, title, tags, content, right_pane }

#}</code></pre></pre>
<p>Put it all together, and you should have an implementation that looks as follows:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
impl Content {
    fn new() -&gt; Content {
        // The main container will hold a left and right pane. The left pane is for user input,
        // whereas the right pane is for the generated output.
        let container = Paned::new(Orientation::Horizontal);
        let left_pane = Box::new(Orientation::Vertical, 5);
        let right_pane = TextBuffer::new(None);
        let right_pane_view = TextView::new_with_buffer(&amp;right_pane);

        // The left pane will consist of a title entry, tags entry, and content text view.
        let title = Entry::new();
        let tags = Entry::new();
        let content = TextBuffer::new(None);
        let content_view = TextView::new_with_buffer(&amp;content);

        // The label that we will display above the content box to describe it.
        let content_label = Label::new(&quot;Content&quot;);
        content_label.set_halign(Align::Center);

        // Set placeholders within the entries to hint the user of the contents to enter.
        title.set_placeholder_text(&quot;Insert Title&quot;);
        tags.set_placeholder_text(&quot;Insert Colon-Delimited Tags&quot;);

        // Additionally set tooltips on the entries. Note that you may use either text or markup.
        title.set_tooltip_text(&quot;Insert the title of article here&quot;);
        tags.set_tooltip_markup(&quot;&lt;b&gt;tag_one&lt;/b&gt;:&lt;b&gt;tag two&lt;/b&gt;:&lt;b&gt; tag three&lt;/b&gt;&quot;);

        // The right pane should disallow editing; and both editors should wrap by word.
        right_pane_view.set_editable(false);
        right_pane_view.set_wrap_mode(WrapMode::Word);
        content_view.set_wrap_mode(WrapMode::Word);

        // Wrap the text views within scrolled windows, so that they can scroll.
        let content_scroller = ScrolledWindow::new(None, None);
        let right_pane_scrolled = ScrolledWindow::new(None, None);
        content_scroller.add(&amp;content_view);
        right_pane_scrolled.add(&amp;right_pane_view);

        // Paddin' Widgets
        left_pane.set_border_width(5);
        right_pane_view.set_left_margin(5);
        right_pane_view.set_right_margin(5);
        right_pane_view.set_top_margin(5);
        right_pane_view.set_bottom_margin(5);
        content_view.set_left_margin(5);
        content_view.set_right_margin(5);
        content_view.set_top_margin(5);
        content_view.set_bottom_margin(5);

        // First add everything to the left pane box.
        left_pane.pack_start(&amp;title, false, true, 0);
        left_pane.pack_start(&amp;tags, false, true, 0);
        left_pane.pack_start(&amp;content_label, false, false, 0);
        left_pane.pack_start(&amp;content_scroller, true, true, 0);

        // Then add the left and right panes into the container
        container.pack1(&amp;left_pane, true, true);
        container.pack2(&amp;right_pane_scrolled, true, true);

        Content { container, title, tags, content, right_pane }
    }
}

#}</code></pre></pre>
<a class="header" href="print.html#programming-the-ui-1" id="programming-the-ui-1"><h1>Programming the UI</h1></a>
<p>So, with all the widgets that are going to interact with each other, you might think that this
part will be a tiny bit difficult to implement. Well, if you think that, you're completely
wrong, as this will actually be the easiest part of the program to implement! Starting with
chapter 1's main function as a template, which looks like so:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // Initialize GTK before proceeding.
    if gtk::init().is_err() {
        eprintln!(&quot;failed to initialize GTK Application&quot;);
        process::exit(1);
    }

    // Initialize the UI's initial state
    let app = App::new();

    // Program your widgets here!

    // Make all the widgets within the UI visible.
    app.window.show_all();

    // Start the GTK main event loop
    gtk::main();
}
</code></pre></pre>
<p>We are going to program the <strong>Post button</strong> to take the <strong>title</strong> and <strong>tags</strong> entries, as well
as the <strong>content</strong> text view's buffer, pass the strings from these widgets directly through
a horrorshow HTML macro, and write the output into the <strong>right_pane's</strong> text buffer. The code for
programming the button will look as follows:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
{
    // Program the post button to take the inputs in the left pane, and update HTML code
    // within the right pane accordingly. Prepared to increment reference counters...
    let title = app.content.title.clone();
    let tags = app.content.tags.clone();
    let content = app.content.content.clone();
    let right_pane = app.content.right_pane.clone();
    app.header.post.connect_clicked(move |_| {
        let inputs = (title.get_text(), tags.get_text(), get_buffer(&amp;content));
        if let (Some(title), Some(tags), Some(content)) = inputs {
            right_pane.set_text(&amp;generate_html(&amp;title, &amp;tags, &amp;content));
        }
    });
}

#}</code></pre></pre>
<p>Note that obtaining the text from an entry is very straightforward. All it takes is to invoke the
<strong>get_text()</strong> method, which returns an <strong>Option&lt;String&gt;</strong>. Getting text from a text buffer is
slightly more difficult, so you will need to use the abstraction that was recommended at the
beginning of this chapter. This function is written as so:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
/// Obtain the entire text buffer's contents as a string.
fn get_buffer(buffer: &amp;TextBuffer) -&gt; Option&lt;String&gt; {
    let start = buffer.get_start_iter();
    let end = buffer.get_end_iter();
    buffer.get_text(&amp;start, &amp;end, true)
}

#}</code></pre></pre>
<p>You will also notice this interesting pattern in Rust that has majorly simplified things for us
when obtaining each of the inputs, to collectively check if all inputs have an input before
attempting to do anything with the inputs. The <strong>if let</strong> syntax in Rust works on more than just
patterns, but tuples as well, so you may check multiple values within a tuple at the same time,
just as you would in a <strong>match</strong>.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let inputs = (title.get_text(), tags.get_text(), get_buffer(&amp;content));
if let (Some(title), Some(tags), Some(content)) = inputs {
    right_pane.set_text(&amp;generate_html(&amp;title, &amp;tags, &amp;content));
}

#}</code></pre></pre>
<p>Althugh we have yet to define our <strong>generate_html</strong> function, and this will be the final
component for implementing this application. The simplest way to use the <strong>html!</strong> macro is to
use it as an argument within the <strong>format!</strong> macro. And so, our function will look as so,
although you are free to implement the HTML macro however you like.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
/// Generates the minified HTML that will be displayed in the right pane
fn generate_html(title: &amp;str, tags: &amp;str, content: &amp;str) -&gt; String {
    format!{
        &quot;{}&quot;,
        html!{
            article {
                header {
                    h1 { : &amp;title }
                    div(class=&quot;tags&quot;) {
                        @ for tag in tags.split(':') {
                            div(class=&quot;tag&quot;) { : tag }
                        }
                    }
                }
                @ for line in content.lines().filter(|x| !x.is_empty()) {
                    p { : line }
                }
            }
        }
    }
}

#}</code></pre></pre>
<p>The above syntax should be fairly readable. We create a pair of <strong>article</strong> tags, which contain
a both a pair of <strong>header</strong> tags, and and a <strong>p</strong> paragraph for each non-empty line of input that
was obtained from the <strong>content</strong> text buffer. Within the <strong>header</strong> tags is a <strong>h1</strong> header that
is defined to use the title entry as the text within, and a <strong>div</strong> that contains a list of tags,
delimited by colons.</p>
<p><img src="images/ch03_complete.png" /></p>
<p>With all this in place, you should have a fully functioning program that looks like the original
picture.</p>
<a class="header" href="print.html#conclusion--review-1" id="conclusion--review-1"><h1>Conclusion &amp; Review</h1></a>
<p><img src="images/ch03_complete.png" /></p>
<p>At this point, you should begin to have a good understanding of how to write GTK
applications with Rust. At this point, you should know how to do the following:</p>
<ul>
<li>Creating, getting, and assigning values to <strong>Labels</strong></li>
<li>Creating, getting, and assigning values to <strong>Entries</strong></li>
<li>Creating, getting, and assigning values to <strong>TextBuffers</strong></li>
<li>Creating and assigning buffers to <strong>TextViews</strong></li>
<li>Creating, styling, and program <strong>Buttons</strong></li>
<li>Assign widgets to <strong>Boxes</strong> and <strong>Paned</strong> containers</li>
<li>Set paddings and margins on widgets</li>
<li>Maintaining External States</li>
</ul>
<a class="header" href="print.html#practice-challenges-1" id="practice-challenges-1"><h2>Practice Challenges</h2></a>
<a class="header" href="print.html#simple-common-mark-editor" id="simple-common-mark-editor"><h1>Simple Common Mark Editor</h1></a>
<p><img src="images/ch04_complete.png" /></p>
<blockquote>
<p>The source code for this chapter can be found <a href="https://github.com/mmstick/gtkrs-tutorials/tree/master/demos/chapter_04">here</a>.</p>
</blockquote>
<p>In this chapter, we will create a useful program for editing text with
Markdown syntax, particularly the Common Mark flavor of Markdown, and
rendering that text into a live HTML preview as text is entered into
the program. We will also be using file chooser dialogs for opening
and saving files, and hashing the buffer to know when the save button
should be enabled. Once completed, you should have an understanding of
how to use not only the <strong>gtk</strong> crate, but <strong>gdk</strong>, <strong>pango</strong>,
<strong>webkit2gtk</strong>, and <strong>sourceview</strong> as well.</p>
<blockquote>
<p>This chapter was actually written with the completed program that
we are going to build. So you could say that this tutorial is now
fully self-hosted and is eating it's own dog food.</p>
</blockquote>
<blockquote>
<p>HTML is allowed to be written in-line within this flavor of Markdown,
so it is possible to mix and match HTML with Markdown in the editor,
and to see it rendered properly on the right.</p>
</blockquote>
<a class="header" href="print.html#prerequisites-1" id="prerequisites-1"><h2>Prerequisites</h2></a>
<p>It's good to have an understanding of how to use types like <strong>RwLock</strong>
and <strong>Mutex</strong> before proceeding, as they will be utilized to maintain
external state of a custom type. They allow for otherwise immutable
values to be mutably borrowed across multiple threads and closures.</p>
<a class="header" href="print.html#dependencies" id="dependencies"><h2>Dependencies</h2></a>
<p>Your dependency list should look similar to the following:</p>
<pre><code class="language-toml">[dependencies]
gdk = &quot;0.6.0&quot;
horrorshow = &quot;0.6.2&quot;
pango = &quot;0.2.0&quot;
pulldown-cmark = &quot;0.1.0&quot;
sourceview = &quot;0.2&quot;
tiny-keccak = &quot;1.4.0&quot;
webkit2gtk = &quot;0.2&quot;

[dependencies.gtk]
features = [&quot;v3_22&quot;]
version = &quot;0.2&quot;
</code></pre>
<a class="header" href="print.html#pulldown-cmark" id="pulldown-cmark"><h3>pulldown-cmark</h3></a>
<p>One will note that we have introduced a few new crates to the mix. Google
has provided the <a href="https://github.com/google/pulldown-cmark">pulldown-cmark crate</a>,
which provides a pull parser for Common Mark Markdown syntax, and thereby allows
us to convert Markdown into HTML.</p>
<a class="header" href="print.html#tiny-keccak" id="tiny-keccak"><h3>tiny-keccak</h3></a>
<p>We will be using a hashing algorithm to determine when the save button should be
sensitive or not. Basically, we will hash the buffer upon each key press and compare
it to the saved file's hash. If the hashes match, the save button shall be enabled.
Otherwise, the save button will be disabled.s</p>
<a class="header" href="print.html#sourceview" id="sourceview"><h3>sourceview</h3></a>
<p>This will provide access to the <strong>GtkSourceView</strong> widget that we will be using
to create the code editor that our editor will be using for editing Markdown.</p>
<a class="header" href="print.html#webkit2gtk" id="webkit2gtk"><h3>webkit2gtk</h3></a>
<p>This will provide the <strong>GtkWebView</strong> widget which we will be using to render
a live preview of our edited Markdown.</p>
<a class="header" href="print.html#pango" id="pango"><h3>pango</h3></a>
<p>This will enable us to edit the font in the <strong>GtkSourceView</strong>.</p>
<a class="header" href="print.html#gdk" id="gdk"><h3>gdk</h3></a>
<p>We will use this to act upon certain key presses</p>
<a class="header" href="print.html#file-chooser-dialogs-source-views--web-views" id="file-chooser-dialogs-source-views--web-views"><h1>File Chooser Dialogs, Source Views, &amp; Web Views</h1></a>
<a class="header" href="print.html#gtkwebview" id="gtkwebview"><h2>GtkWebView</h2></a>
<p><img src="images/web_view.png" /></p>
<p>Provided by the <a href="https://crates.io/crates/webkit2gtk">webkit2gtk crate</a>, this a widget that
already integrates a scrolled window and simply provides an embedded web engine for rendering
HTML. The purpose of this widget within this chapter is to provide the rendered HTML
representations of the markdown text within the source buffer.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let context = WebContext::get_default().unwrap();
let webview = WebView::new_with_context(&amp;context);

#}</code></pre></pre>
<p>For our purposes, we will simply be shuttling the HTML output of the horrorshow crate into
the web view directly, which can be done by using the <code>load_html()</code> method.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
webview.load_html(&amp;html, None);

#}</code></pre></pre>
<a class="header" href="print.html#gtksourceview" id="gtksourceview"><h2>GtkSourceView</h2></a>
<p><img src="images/source_view.png" /></p>
<p>Provided by the <a href="https://crates.io/crates/sourceview">sourceview crate</a>, this is an enhanced
<strong>GtkTextView</strong> which provides some much-needed code editing improvements. Alas, don't expect
too much from it, as it's still relatively primitive in it's current state.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let source_buffer = Buffer::new(None);
let source_view = View::new_with_buffer(&amp;source_buffer);

#}</code></pre></pre>
<p>The default settings are basically no different from a normal <strong>GtkTextView</strong> though, so
you will immediately want to configure the source view that you create according to your
needs, as we will see in this tutorial.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
source_view.set_show_line_numbers(true);
source_view.set_monospace(true);
let font = FontDescription::from_string(&quot;monospace 11&quot;);
WidgetExt::override_font(&amp;source_view, &amp;font);

#}</code></pre></pre>
<a class="header" href="print.html#gtkfilechooserdialog" id="gtkfilechooserdialog"><h2>GtkFileChooserDialog</h2></a>
<p><img src="images/file_chooser_dialog.png" /></p>
<p><strong>GtkFileChooserDialogs</strong> will be used to program the file open/save/save as buttons. They
simply open a file chooser dialog where you are given the choice to select a file. The GTK
Rust API is a bit under-developed in this part, as you will see. One particular gotcha is
that the <strong>FileChooserDialogs</strong> that you obtain from this API do not take advantage of
Rust's <strong>Drop</strong> trait. Not to worry though, as we will be creating abstractions ourselves.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
// Create a new file chooser dialog for opening a file.
let open_dialog = FileChooserDialog::new(
    Some(&quot;Open&quot;),
    Some(&amp;Window::new(WindowType::Popup)),
    FileChooserAction::Open,
);

// Add the cancel and open buttons to that dialog.
open_dialog.add_button(&quot;Cancel&quot;, ResponseType::Cancel.into());
open_dialog.add_button(&quot;Open&quot;, ResponseType::Ok.into());

// Run the dialog and the response type back.
if open_dialog.run() == ResponseType::Ok.into() {
    if let Some(filename) = open_dialog.get_filename() {
        // Do something with the received `PathBuf`.
    }
}

// Destroy the dialog window. Be careful not to return from a function
// without first destroying the dialog! A wrapper type will help.
open_dialog.destroy();

#}</code></pre></pre>
<a class="header" href="print.html#setting-up-modules" id="setting-up-modules"><h1>Setting Up Modules</h1></a>
<p><img src="images/ch04_mod_diagram.png" /></p>
<p>With this chapter, we are going to begin to use modules to compartmentalize
code within manageable files. Following the above diagram, we shall separate
the GTK-specific code from the rest of the codebase accordingly.</p>
<ul>
<li>The <strong>ui</strong> module will contain all of the code relevant to building and
executing the GTK program.</li>
<li>The <strong>preview</strong> module will be responsible for generating the HTML from the
provided Markdown.</li>
<li>The <strong>state</strong> module will be responsible for holding our custom types that
will be managing external state within the program.</li>
</ul>
<a class="header" href="print.html#creating-modules" id="creating-modules"><h2>Creating Modules</h2></a>
<p><img src="images/ch04_mod_structure.png" /></p>
<p>The <strong>preview</strong> and <strong>state</strong> modules are relatively simple, and so they
can simply be individual Rust files: <strong>preview.rs</strong> and <strong>state.rs</strong>. The
<strong>ui</strong> module will be much more complex, however, and so that module will
consist of a series of modules on it's own. As a result, it should be a
<strong>ui</strong> directory where the point of entry into this module will be a
<strong>mod.rs</strong> file within that directory.</p>
<a class="header" href="print.html#the-mainrs-file" id="the-mainrs-file"><h2>The main.rs File</h2></a>
<p>Once we have the basic modules set up, we will wire everything together
to the main point of entry into our program: the <strong>main.rs</strong> file. It
should look like so to get started.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate gdk;
extern crate gtk;
#[macro_use]
extern crate horrorshow;
extern crate pango;
extern crate pulldown_cmark;
extern crate sourceview;
extern crate tiny_keccak;
extern crate webkit2gtk;

pub mod preview;
pub mod state;
pub mod ui;

use ui::App;

fn main() {
    // Initialize the UI's initial state
    App::new()
        // Connect events to the UI
        .connect_events()
        // Display the UI and execute the program
        .then_execute();
}
</code></pre></pre>
<p>You may notice that we have changed things up from the last chapter. In
this chapter, we are going to use the <strong>Builder</strong> pattern to set up and
execute our program. This can be a useful pattern to employ that can
eliminate would-be API logic errors at compile time.</p>
<p>The <code>App::new()</code> method will create a new <strong>App</strong>, which we will move
into the <code>connect_events()</code> method, which converts the <strong>App</strong> into a
<strong>ConnectedApp</strong>, and that type implements <code>then_execute()</code>, which shall
display the UI and execute the main event loop.</p>
<a class="header" href="print.html#the-uimiscrs-module" id="the-uimiscrs-module"><h1>The ui/misc.rs Module</h1></a>
<p>We are going to implement a few helper methods that will be utilized across
the project on an as-needed basis. This is purely to serve some useful
abstractions. The two functions that we are going to provide is an abstraction
for obtaining the text within a <strong>GtkSourceBuffer</strong>, and for setting the title
of a <strong>GtkHeaderBar</strong> with a given <strong>Path</strong>.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
use gtk::*;
use sourceview::*;
use std::path::Path;

/// Sets the title of the header bar to the file name of the given path.
pub fn set_title(headerbar: &amp;HeaderBar, path: &amp;Path) {
    if let Some(filename) = path.file_name() {
        let filename: &amp;str = &amp;filename.to_string_lossy();
        headerbar.set_title(filename);
    }
}

/// Obtains the entire inner string of a given text buffer.
pub fn get_buffer(buffer: &amp;Buffer) -&gt; Option&lt;String&gt; {
    let start = buffer.get_start_iter();
    let end = buffer.get_end_iter();
    buffer.get_text(&amp;start, &amp;end, true)
}

#}</code></pre></pre>
<a class="header" href="print.html#creating-the-ui-structure-2" id="creating-the-ui-structure-2"><h1>Creating the UI Structure</h1></a>
<p><img src="images/ch04_ui_diagram.png" /></p>
<p>Following the above diagram, we will begin by creating three modules
within the <strong>ui</strong> module: <strong>app.rs</strong>, <strong>header.rs</strong>, <strong>content.rs</strong>.
These three files will hold the <strong>App</strong>, <strong>ConnectedApp</strong>, <strong>Header</strong>,
<strong>Content</strong>, and <strong>Source</strong> structures.</p>
<a class="header" href="print.html#implementing-the-ui-module-uimodrs" id="implementing-the-ui-module-uimodrs"><h2>Implementing the UI Module (ui/mod.rs)</h2></a>
<p>Now that UI-related code is separated into it's own module, it's
important to declare all of the submodules that this module will
important, and declare any types and functions that this module
should re-export.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
mod app;
mod content;
mod dialogs;
mod header;
pub mod misc;
pub mod save;

pub use self::app::App;
pub use self::content::Content;
pub use self::dialogs::{OpenDialog, SaveDialog};
pub use self::header::Header;

#}</code></pre></pre>
<p>As can be seen above, we are going to create the following modules:
<strong>app.rs</strong>, <strong>content.rs</strong>, <strong>dialogs.rs</strong>, <strong>save.rs</strong>, <strong>header.rs</strong>,
and <strong>misc.rs</strong>.</p>
<a class="header" href="print.html#implementing-the-app-structure-uiapprs" id="implementing-the-app-structure-uiapprs"><h2>Implementing the App Structure (ui/app.rs)</h2></a>
<p>This section should be fairly straightforward, as it is essentially
identical to previous chapters. The one main difference to note
is that we have moved the initialization of GTK into the beginning
of the <strong>App</strong> implementation.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
use gtk;
use gtk::*;
use super::Header;
use super::Content;

pub struct App {
    pub window:  Window,
    pub header:  Header,
    pub content: Content,
}

impl App {
    pub fn new() -&gt; App {
        // Initialize GTK before proceeding.
        if gtk::init().is_err() {
            eprintln!(&quot;failed to initialize GTK Application&quot;);
            process::exit(1);
        }

        // Create a new top level window.
        let window = Window::new(WindowType::Toplevel);
        // Create a the headerbar and it's associated content.
        let header = Header::new();
        // Create the content container and all of it's widgets.
        let content = Content::new();

        // Set the headerbar as the title bar widget.
        window.set_titlebar(&amp;header.container);
        // Set the title of the window.
        window.set_title(&quot;Markdown Editor&quot;);
        // Set the window manager class.
        window.set_wmclass(&quot;md-editor&quot;, &quot;Markdown Editor&quot;);
        // The icon the app will display.
        window.set_default_size(800, 600);
        Window::set_default_icon_name(&quot;iconname&quot;);
        // Add the content to the window.
        window.add(&amp;content.container);

        // Programs what to do when the exit button is used.
        window.connect_delete_event(move |_, _| {
            main_quit();
            Inhibit(false)
        });

        // Return the application structure.
        App { window, header, content }
    }
}

#}</code></pre></pre>
<a class="header" href="print.html#implementing-the-header-structure-uiheaderrs" id="implementing-the-header-structure-uiheaderrs"><h2>Implementing the Header Structure (ui/header.rs)</h2></a>
<p>This structure will be even easier to implement. We will be implementing
<strong>Open</strong>, <strong>Save</strong>, and <strong>Save As</strong> buttons within the header bar. We
shall set their labels with a mnemonic, so that users have the ability
to hold the <strong>Alt</strong> key, and select the button that they want to click
by hitting the character that is underlined in the button label.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
use gtk::*;

pub struct Header {
    pub container: HeaderBar,
    pub open:      Button,
    pub save:      Button,
    pub save_as:   Button,
}

impl Header {
    pub fn new() -&gt; Header {
        // Creates the main header bar container widget.
        let container = HeaderBar::new();

        // Sets the text to display in the title section of the header bar.
        container.set_title(&quot;Markdown Editor&quot;);
        // Enable the window controls within this headerbar.
        container.set_show_close_button(true);

        let open = Button::new_with_mnemonic(&quot;_Open&quot;);
        let save = Button::new_with_mnemonic(&quot;_Save&quot;);
        let save_as = Button::new_with_mnemonic(&quot;Save _As&quot;);
        container.pack_start(&amp;open);
        container.pack_end(&amp;save_as);
        container.pack_end(&amp;save);

        // Returns the header and all of it's state
        Header { container, open, save, save_as }
    }
}


#}</code></pre></pre>
<a class="header" href="print.html#implementing-the-content-structure-uicontentrs" id="implementing-the-content-structure-uicontentrs"><h2>Implementing the Content Structure (ui/content.rs)</h2></a>
<p>This is where we are going to introduce <strong>GtkWebViews</strong>,
and <strong>GtkSourceViews</strong>.</p>
<a class="header" href="print.html#creating-a-web-view" id="creating-a-web-view"><h3>Creating a Web View</h3></a>
<p>Web views are very simple to create. By invoking the following code,
you will have constructed a web view that you may integrate within
your UI the same as you do with all other widgets.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
// Create a the WebView for the preview pane.
let context = WebContext::get_default().unwrap();
let preview = WebView::new_with_context(&amp;context);

#}</code></pre></pre>
<p>These web views come already wrapped with scrolling capabilities,
so that functionality does not have to implemented.</p>
<a class="header" href="print.html#creating--configuring-source-views" id="creating--configuring-source-views"><h3>Creating &amp; Configuring Source Views</h3></a>
<p>Source views, on the other hand, are a bit more complex, because
they will require some additional configuration to get the results
that you want in your UI. We are going to strive to have the
following default configuration for our source view:</p>
<ul>
<li>Tabs should write four spaces</li>
<li>The view should show line numbers</li>
<li>We should use the default monospace font at size 11</li>
<li>Markdown syntax highlighting</li>
<li>Attempt to use the Builder theme by default, and fallback to Classic</li>
</ul>
<p>First we start by constructing our <strong>Source</strong> structure.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
pub struct Source {
    pub container: ScrolledWindow,
    pub view:      View,
    pub buff:      Buffer,
}

impl Source {
    fn new() -&gt; Source {

    }
}

#}</code></pre></pre>
<p>Then we will create our source buffer and view, which is identical to
how we would do it with a regular text buffer and view. Once created,
we will wrap the view within a scrolled window.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
// Create the SourceView for the editor on the left pane.
let buff = Buffer::new(None);
let view = View::new_with_buffer(&amp;buff);
let container = ScrolledWindow::new(None, None);
container.add(&amp;view);

#}</code></pre></pre>
<p>Then we set our desired configurations:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
view.set_show_line_numbers(true);
view.set_monospace(true);
view.set_insert_spaces_instead_of_tabs(true);
view.set_indent_width(4);
// TODO: Next GTK Crate Release
// view.set_input_hints(InputHints::SPELLCHECK + InputHints::WORD_COMPLETION);

#}</code></pre></pre>
<p>We can use the <strong>pango</strong> crate to change the font within the view. Note
that we needed to explicitly declare from which trait the <strong>override_font</strong>
method comes from. A future GTK Rust API update may address this issue.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
// Configures the font to use with our source view, which shall be the default monospace
// font, at size 11. When overriding the font, we need to explicitly state the trait
// from where the method is coming from, due to two methods implementing the same method.
let font = FontDescription::from_string(&quot;monospace 11&quot;);
WidgetExt::override_font(&amp;view, &amp;font);

#}</code></pre></pre>
<p>Then we want to enable markdown syntax highlighting by default. Languages
are obtained from a <strong>LanguageManager</strong>. We will assign the language
directly to the source buffer, rather than the source view.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
// Configure markdown syntax highlighting
if let Some(markdown) = LanguageManager::new().get_language(&quot;markdown&quot;) {
    buff.set_language(&amp;markdown);
}

#}</code></pre></pre>
<a class="header" href="print.html#completed-source-code" id="completed-source-code"><h3>Completed Source Code</h3></a>
<p>Altogether, the source code for this file should be as follows:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
use gtk::*;
use pango::*;
use sourceview::*;
use webkit2gtk::*;

pub struct Content {
    pub container: Paned,
    pub source:    Source,
    pub preview:   WebView,
}

pub struct Source {
    pub container: ScrolledWindow,
    pub view:      View,
    pub buff:      Buffer,
}

impl Content {
    pub fn new() -&gt; Content {
        // Create the Paned container for the main content
        let container = Paned::new(Orientation::Horizontal);
        let source = Source::new();

        // Create a the WebView for the preview pane.
        let context = WebContext::get_default().unwrap();
        let preview = WebView::new_with_context(&amp;context);

        // Pack it in
        container.pack1(&amp;source.container, true, true);
        container.pack2(&amp;preview, true, true);

        // Ensure that the two panes get half the size of the paned container.
        source.container.set_size_request(100, -1);
        preview.set_size_request(100, -1);

        Content { container, source, preview }
    }
}

impl Source {
    pub fn new() -&gt; Source {
        // Create the SourceView for the editor on the left pane.
        let buff = Buffer::new(None);
        let view = View::new_with_buffer(&amp;buff);
        let container = ScrolledWindow::new(None, None);
        container.add(&amp;view);

        // Set source view settings
        view.set_show_line_numbers(true);
        view.set_monospace(true);
        view.set_insert_spaces_instead_of_tabs(true);
        view.set_indent_width(4);

        // Configures the font to use with our source view, which shall be the default monospace
        // font, at size 11. When overriding the font, we need to explicitly state the trait
        // from where the method is coming from, due to two methods implementing the same method.
        let font = FontDescription::from_string(&quot;monospace 11&quot;);
        WidgetExt::override_font(&amp;view, &amp;font);

        // Configure markdown syntax highlighting
        if let Some(markdown) = LanguageManager::new().get_language(&quot;markdown&quot;) {
            buff.set_language(&amp;markdown);
        }

        // Set the theme of source buffer
        let manager = StyleSchemeManager::new();
        if let Some(theme) = manager.get_scheme(&quot;Builder&quot;).or(manager.get_scheme(&quot;Classic&quot;)) {
            buff.set_style_scheme(&amp;theme);
        }

        Source { container, buff, view }
    }
}

#}</code></pre></pre>
<a class="header" href="print.html#maintaining-external-state-1" id="maintaining-external-state-1"><h1>Maintaining External State</h1></a>
<p>This section covers the <strong>state.rs</strong> module which will hold the types that
we will be using to maintain non-GTK external state across the GTK UI. This
will honestly be incredibly simple and short, because this iteration of the
markdown editor does not have much state to be concerned about.</p>
<a class="header" href="print.html#planning-what-we-need" id="planning-what-we-need"><h2>Planning What We Need</h2></a>
<p>There are two key components that we need to be aware of throughout the
lifetime of this application: the <strong>file path</strong> of the currently-active
file that we are editing, and a <strong>hash sum</strong> of the file's contents to compare
with the content of the current editor in order to know when we should
disable/enable the save button.</p>
<a class="header" href="print.html#activemetadata" id="activemetadata"><h2>ActiveMetadata</h2></a>
<p>And so, the <strong>ActiveMetadata</strong> structure was born. It contains a <strong>PathBuf</strong>
for storing the path of the active file, and a 64-byte hash sum that will
be generated by <strong>keccak512()</strong> from the
<a href="https://docs.rs/tiny-keccak/1.4.0/tiny_keccak/fn.keccak512.html">tiny-keccak</a>
crate.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
use std::path::{Path, PathBuf};
use tiny_keccak::keccak512;

pub struct ActiveMetadata {
    path: PathBuf,
    sum:  [u8; 64],
}

#}</code></pre></pre>
<p>The <strong>impl</strong> for this type will be fairly simple. We simply need a way to
create a new active metadata, a means of getting a reference to the internal
path, a conditional check to determine if given data computes the same sum
as the internal sum, and a means of updating the internal sum for when we
save a file.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
impl ActiveMetadata {
    pub fn new(path: PathBuf, data: &amp;[u8]) -&gt; ActiveMetadata {
        ActiveMetadata { path, sum: keccak512(data) }
    }

    pub fn get_path&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a Path { &amp;self.path }

    pub fn get_dir(&amp;self) -&gt; Option&lt;PathBuf&gt; { self.path.parent().map(|p| p.to_path_buf()) }

    pub fn is_same_as(&amp;self, data: &amp;[u8]) -&gt; bool { &amp;keccak512(data)[..] == &amp;self.sum[..] }

    pub fn set_sum(&amp;mut self, data: &amp;[u8]) { self.sum = keccak512(data); }
}

#}</code></pre></pre>
<a class="header" href="print.html#connecting-events" id="connecting-events"><h1>Connecting Events</h1></a>
<p>This is where we begin to do the magic of getting our UI to actually
do stuff. Revisiting our <strong>app.rs</strong> module, we will now add the
<strong>App::connect_events()</strong> method.</p>
<a class="header" href="print.html#connectedapp" id="connectedapp"><h2>ConnectedApp</h2></a>
<p>Before we begin, however, we should create the <strong>ConnectedApp</strong> wrapper
in advance, which implements the <strong>then_execute()</strong> method that we saw before.
The goal will be to convert the <strong>App</strong> into a <strong>ConnectedApp</strong> after the
<strong>App::connect_events()</strong> method is invoked on the <strong>App</strong>.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
/// A wrapped `App` which provides the capability to execute the program.
pub struct ConnectedApp(App);

impl ConnectedApp {
    /// Display the window, and execute the gtk main event loop.
    pub fn then_execute(self) {
        self.0.window.show_all();
        gtk::main();
    }
}

#}</code></pre></pre>
<a class="header" href="print.html#connect_events" id="connect_events"><h2>connect_events()</h2></a>
<p>Moving on, we will finally add the <strong>App::connect_events()</strong> method to the <strong>impl</strong>
for the <strong>App</strong> type, which we will define to take ownership of the <strong>App</strong>
and return a <strong>ConnectedApp</strong> at the end. This is</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
/// Creates external state, and maps all of the UI functionality to the UI.
impl App {
    pub fn new() -&gt; App { ... }

    pub fn connect_events(self) -&gt; ConnectedApp {
        // External state to share across events.
        let current_file = Arc::new(RwLock::new(None));

        // Connect all of the events that this UI will act upon.
        self.editor_changed(
            current_file.clone(),
            &amp;self.header.save.clone()
        );

        // Wrap the `App` within `ConnectedApp` to enable the developer
        // to execute the program.
        ConnectedApp(self)
    }
}

#}</code></pre></pre>
<p>Using the <strong>ActiveMetadata</strong> type that we created before to maintain the
extern state in regards to the currently-active file, we will create a
<strong>RwLock'd</strong> <strong>current_file</strong> variable, which will contain an
<strong>Option&lt;ActiveMetadata&gt;</strong>. By default, this will be set to <strong>None</strong>,
as at first there will not be a file opened to track.</p>
<p>The first event to connect to our application will be to act upon changes
to the source buffer, which we will implement in a <strong>App::editor_changed()</strong>
method. This method will take a reference to our <strong>RwLock'd</strong> <strong>current_file</strong>,
as well as a reference to the <strong>Save</strong> button. The purpose of passing the
save button in will be to modify it's <em>sensitivity</em> based on the contents of
the buffer.</p>
<blockquote>
<p>A button that is not sensitive, is a button that you cannot click.</p>
</blockquote>
<a class="header" href="print.html#markdown-to-html" id="markdown-to-html"><h1>Markdown to HTML</h1></a>
<p>Before we implement the <strong>connect_changed()</strong> method, we need to first
implement the <strong>preview</strong> module that this method will use to get the
HTML string to pass on to the web view.</p>
<p>There are two steps to the process of converting markdown into HTML. The first
step involves simply converting the markdown into HTML! Yet that's not enough,
you also need to embed that within additional HTML to style it and get some
syntax highlighting support with a bit of JavaScript. Not to worry though,
because we will be using <strong>highlight.js</strong> to take care of syntax highlighting
for us.</p>
<a class="header" href="print.html#converting-markdown-to-html" id="converting-markdown-to-html"><h2>Converting Markdown to HTML</h2></a>
<p>Google has thankfully provided a crate to do just this with
<a href="https://github.com/google/pulldown-cmark">pulldown-cmark</a>. It notes that
it is implemented as a pull parser for increased efficiency compared to
non-pull parsers. All you have to do is provide markdown text in a <strong>&amp;str</strong>
to the provider <strong>Parser</strong>, and then suppliy a mutable <strong>String</strong> reference
to pull in the HTML equivalent of the markup.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
use pulldown_cmark::{html, Parser};

/// In goes markdown text; out comes HTML text.
fn mark_to_html(markdown: &amp;str) -&gt; String {
    let parser = Parser::new(&amp;markdown);
    let mut buffer = String::new();
    html::push_html(&amp;mut buffer, parser);
    buffer
}

#}</code></pre></pre>
<a class="header" href="print.html#applying-styling-to-our-html" id="applying-styling-to-our-html"><h2>Applying Styling to Our HTML</h2></a>
<p>But we don't want to stop there, so we will use the above function within
our public <strong>render()</strong> function to integrate it alongside some CSS and
JavaScript to get the desired HTML output in the web view.</p>
<blockquote>
<p>Note that we are supplying the HTML from our markdown into the <strong>body</strong>
section of the HTML page, and have it wrapped as a <strong>Raw</strong> string to
tell the <strong>horrorshow</strong> macro to not escape the inner text. You may
apply additional styling if you would prefer even more styling to your
text.</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
use horrorshow::Raw;
use horrorshow::helper::doctype;

/// In goes markdown text; out comes stlyish HTML text.
pub fn render(markdown: &amp;str) -&gt; String {
    format!(
        &quot;{}&quot;,
        html!(
            : doctype::HTML;
            html {
                head {
                    link(rel=&quot;stylesheet&quot;, href=&quot;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css&quot;) {}
                    script(src=&quot;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js&quot;) {}
                    script(src=&quot;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/rust.min.js&quot;) {}
                    script {
                        : Raw(&quot;hljs.initHighlightingOnLoad()&quot;)
                    }
                    style {
                        : &quot;body { width: 80%; margin: 0 auto }&quot;;
                        : &quot;img { max-width: 80% }&quot;
                    }
                }
                body {
                    : Raw(&amp;mark_to_html(markdown));
                }
            }
        )
    )
}

#}</code></pre></pre>
<a class="header" href="print.html#updating-webviews" id="updating-webviews"><h1>Updating WebViews</h1></a>
<p>The first capability that we will connect to our UI is to update the web view
preview dynamically as text in the source buffer is changed. We will begin
by creating a new <strong>App::editor_changed()</strong> method for <strong>App</strong>, which takes the
<strong>current_file</strong> component, and a reference to the <strong>save</strong> button so that we
can disable and enable the button over time, to indicate whether changes have
been made that require saving.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
/// Updates the WebView when the SourceBuffer is modified.
fn editor_changed(
    &amp;self,
    current_file: Arc&lt;RwLock&lt;Option&lt;ActiveMetadata&gt;&gt;&gt;,
    save_button: &amp;Button,
) {
    let preview = self.content.preview.clone();
    let save_button = save_button.clone();
    self.content.source.buff.connect_changed(move |editor| {
        if let Some(markdown) = get_buffer(&amp;editor) {
            preview.load_html(&amp;render(&amp;markdown), None);
            if let Some(ref current_file) = *current_file.read().unwrap() {
                let has_same_sum = current_file.is_same_as(&amp;markdown.as_bytes());
                save_button.set_sensitive(!has_same_sum);
            }
        }
    });
}

#}</code></pre></pre>
<a class="header" href="print.html#connect_changed" id="connect_changed"><h2>connect_changed()</h2></a>
<p>In the above code, you may notice that we are calling utilizing the
<strong>connect_changed</strong> method from the source buffer to update the preview
and modify the save button as the buffer is modified.</p>
<a class="header" href="print.html#obtaining-text-from-a-source-buffer" id="obtaining-text-from-a-source-buffer"><h2>Obtaining Text From a Source Buffer</h2></a>
<p>Using the <strong>get_buffer()</strong> function from the <strong>misc.rs</strong> module:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
if let Some(markdown) = get_buffer(&amp;editor) {

}

#}</code></pre></pre>
<p>We can obtain the text within the editor's buffer.</p>
<a class="header" href="print.html#updating-the-web-view" id="updating-the-web-view"><h2>Updating the Web View</h2></a>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
preview.load_html(&amp;render(&amp;markdown), None);

#}</code></pre></pre>
<p>Whereas here we are using the <strong>render()</strong> function from the <strong>preview</strong> module
to convert the <code>markdown</code> text into an HTML string; and then immediately pass
that HTML into our <code>preview</code> web view with the <strong>load_html()</strong> method.</p>
<a class="header" href="print.html#modifying-the-save-button" id="modifying-the-save-button"><h2>Modifying the Save Button</h2></a>
<p>The last piece of the puzzle is this section, where we obtain a read-only
lock to the current file, and check if the text in the buffer generates
the same hash as the the hash we saved to the disk. If there's a match,
the save button will be disabled; and if there's no match, it will be
enabled.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
if let Some(ref current_file) = *current_file.read().unwrap() {
    let has_same_sum = current_file.is_same_as(&amp;markdown.as_bytes());
    save_button.set_sensitive(!has_same_sum);
}

#}</code></pre></pre>
<a class="header" href="print.html#markdown-to-html-1" id="markdown-to-html-1"><h1>Markdown to HTML</h1></a>
<p>Before we implement the <strong>connect_changed()</strong> method, we need to first
implement the <strong>preview</strong> module that this method will use to get the
HTML string to pass on to the web view.</p>
<p>There are two steps to the process of converting markdown into HTML. The first
step involves simply converting the markdown into HTML! Yet that's not enough,
you also need to embed that within additional HTML to style it and get some
syntax highlighting support with a bit of JavaScript. Not to worry though,
because we will be using <strong>highlight.js</strong> to take care of syntax highlighting
for us.</p>
<a class="header" href="print.html#converting-markdown-to-html-1" id="converting-markdown-to-html-1"><h2>Converting Markdown to HTML</h2></a>
<p>Google has thankfully provided a crate to do just this with
<a href="https://github.com/google/pulldown-cmark">pulldown-cmark</a>. It notes that
it is implemented as a pull parser for increased efficiency compared to
non-pull parsers. All you have to do is provide markdown text in a <strong>&amp;str</strong>
to the provider <strong>Parser</strong>, and then suppliy a mutable <strong>String</strong> reference
to pull in the HTML equivalent of the markup.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
use pulldown_cmark::{html, Parser};

/// In goes markdown text; out comes HTML text.
fn mark_to_html(markdown: &amp;str) -&gt; String {
    let parser = Parser::new(&amp;markdown);
    let mut buffer = String::new();
    html::push_html(&amp;mut buffer, parser);
    buffer
}

#}</code></pre></pre>
<a class="header" href="print.html#applying-styling-to-our-html-1" id="applying-styling-to-our-html-1"><h2>Applying Styling to Our HTML</h2></a>
<p>But we don't want to stop there, so we will use the above function within
our public <strong>render()</strong> function to integrate it alongside some CSS and
JavaScript to get the desired HTML output in the web view.</p>
<blockquote>
<p>Note that we are supplying the HTML from our markdown into the <strong>body</strong>
section of the HTML page, and have it wrapped as a <strong>Raw</strong> string to
tell the <strong>horrorshow</strong> macro to not escape the inner text. You may
apply additional styling if you would prefer even more styling to your
text.</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
use horrorshow::Raw;
use horrorshow::helper::doctype;

/// In goes markdown text; out comes stlyish HTML text.
pub fn render(markdown: &amp;str) -&gt; String {
    format!(
        &quot;{}&quot;,
        html!(
            : doctype::HTML;
            html {
                head {
                    link(rel=&quot;stylesheet&quot;, href=&quot;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css&quot;) {}
                    script(src=&quot;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js&quot;) {}
                    script(src=&quot;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/rust.min.js&quot;) {}
                    script {
                        : Raw(&quot;hljs.initHighlightingOnLoad()&quot;)
                    }
                    style {
                        : &quot;body { width: 80%; margin: 0 auto }&quot;;
                        : &quot;img { max-width: 80% }&quot;
                    }
                }
                body {
                    : Raw(&amp;mark_to_html(markdown));
                }
            }
        )
    )
}

#}</code></pre></pre>
<a class="header" href="print.html#file-chooser-dialogs" id="file-chooser-dialogs"><h1>File Chooser Dialogs</h1></a>
<blockquote>
<p>Note that this is the dialogs.rs module</p>
</blockquote>
<p>The GTK Rust API does not take advantage of the <strong>Drop</strong> trait within
Rust, which means that when a dialog is spawned, it will continue
to remain in existence on your screen forever. Thankfully, we can
address this ourselves by creating wrapper types for
<strong>GtkFileChooserDialogs</strong> and implementing the <strong>Drop</strong> trait on
them to destroy the inner dialog upon dropping the type.</p>
<a class="header" href="print.html#creating-an-opendialog" id="creating-an-opendialog"><h2>Creating an OpenDialog</h2></a>
<p>With this, you will start by simply creating a new tuple type.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
pub struct OpenDialog(FileChooserDialog);

#}</code></pre></pre>
<p>And simply implementing the <strong>new()</strong> method on this type to
create a new inner <strong>FileChooserDialog</strong>.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
impl OpenDialog {
    pub fn new(path: Option&lt;PathBuf&gt;) -&gt; OpenDialog {
        // Create a new file chooser dialog for opening a file.
        let open_dialog = FileChooserDialog::new(
            Some(&quot;Open&quot;),
            Some(&amp;Window::new(WindowType::Popup)),
            FileChooserAction::Open,
        );

        // Add the cancel and open buttons to that dialog.
        open_dialog.add_button(&quot;Cancel&quot;, ResponseType::Cancel.into());
        open_dialog.add_button(&quot;Open&quot;, ResponseType::Ok.into());

        // Set the default path to open this with.
        path.map(|p| open_dialog.set_current_folder(p));

        OpenDialog(open_dialog)
    }
}

#}</code></pre></pre>
<p>The gist of a <strong>FileChooserDialog</strong> is to designate the name of
the dialog, followed by providing a new window of the <strong>Popup</strong>
variety, and then choosing the corresponding <strong>FileChooserAction</strong>
that meets the criteria that you are going for. In this case, we
are creating an <strong>Open</strong> dialog to open a file.</p>
<p>Once created, you then need to specify the labels for the two
buttons within the dialog, and map the corresponding
<strong>ResponseTypes</strong> to those buttons. This is very important for
knowing whether the user hit <strong>Cancel</strong> or <strong>Ok</strong>.</p>
<p>Once we are all done, we simply need to wrap the type up in our
<strong>OpenDialog</strong> type and that's it.</p>
<a class="header" href="print.html#creating-a-savedialog" id="creating-a-savedialog"><h2>Creating a SaveDialog</h2></a>
<p>The Save dialog is essentially identical.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
pub struct SaveDialog(FileChooserDialog);

impl SaveDialog {
    pub fn new(path: Option&lt;PathBuf&gt;) -&gt; SaveDialog {
        // Initializes a new save as dialog, which is embedded within a new popup window.
        let save_dialog = FileChooserDialog::new(
            Some(&quot;Save As&quot;),
            Some(&amp;Window::new(WindowType::Popup)),
            FileChooserAction::Save,
        );

        // Add the cancel and save buttons to that dialog.
        save_dialog.add_button(&quot;Cancel&quot;, ResponseType::Cancel.into());
        save_dialog.add_button(&quot;Save&quot;, ResponseType::Ok.into());

        // Set the default path to open this with.
        path.map(|p| save_dialog.set_current_folder(p));

        SaveDialog(save_dialog)
    }
}

#}</code></pre></pre>
<a class="header" href="print.html#implementing-the-drop-trait" id="implementing-the-drop-trait"><h2>Implementing the Drop Trait</h2></a>
<p>Objects within GTK are destroyed with the <strong>destroy()</strong> method. So,
if we want to destroy our dialogs after we have thrown their handles
away, we can do this automatically by implementing the <strong>Drop</strong> trait
on both of the types by hand.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
impl Drop for OpenDialog {
    fn drop(&amp;mut self) { self.0.destroy(); }
}

impl Drop for SaveDialog {
    fn drop(&amp;mut self) { self.0.destroy(); }
}

#}</code></pre></pre>
<p>Very stupid simple. We are simply calling the <strong>destroy()</strong> method
on the inner value of our new types.</p>
<a class="header" href="print.html#implementing-helpful-methods" id="implementing-helpful-methods"><h2>Implementing Helpful Methods</h2></a>
<p>The following method can be added to the impl for both types, and they
simply make it easier to run and get the outputs that we want from the
dialogs.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
pub fn run(&amp;self) -&gt; Option&lt;PathBuf&gt; {
    if self.0.run() == ResponseType::Ok.into() {
        self.0.get_filename()
    } else {
        None
    }
}

#}</code></pre></pre>
<p>Basically, we display/run the dialog, and check the output to determine
whether or not we received the <strong>Ok</strong> response. If we received the <strong>Ok</strong>
response, we simply attempt to return the filename that may or may not
have been selected.</p>
<a class="header" href="print.html#the-final-code" id="the-final-code"><h2>The Final Code</h2></a>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
use gtk::*;
use std::path::PathBuf;

/// A wrapped FileChooserDialog that automatically destroys itself upon being dropped.
pub struct OpenDialog(FileChooserDialog);

/// A wrapped FileChooserDialog that automatically destroys itself upon being dropped.
pub struct SaveDialog(FileChooserDialog);

impl OpenDialog {
    pub fn new() -&gt; OpenDialog {
        // Create a new file chooser dialog for opening a file.
        let open_dialog = FileChooserDialog::new(
            Some(&quot;Open&quot;),
            Some(&amp;Window::new(WindowType::Popup)),
            FileChooserAction::Open,
        );

        // Add the cancel and open buttons to that dialog.
        open_dialog.add_button(&quot;Cancel&quot;, ResponseType::Cancel.into());
        open_dialog.add_button(&quot;Open&quot;, ResponseType::Ok.into());

        OpenDialog(open_dialog)
    }

    pub fn run(&amp;self) -&gt; Option&lt;PathBuf&gt; {
        if self.0.run() == ResponseType::Ok.into() {
            self.0.get_filename()
        } else {
            None
        }
    }
}

impl SaveDialog {
    pub fn new() -&gt; SaveDialog {
        // Initializes a new save as dialog, which is embedded within a new popup window.
        let save_dialog = FileChooserDialog::new(
            Some(&quot;Save As&quot;),
            Some(&amp;Window::new(WindowType::Popup)),
            FileChooserAction::Save,
        );

        // Add the cancel and save buttons to that dialog.
        save_dialog.add_button(&quot;Cancel&quot;, ResponseType::Cancel.into());
        save_dialog.add_button(&quot;Save&quot;, ResponseType::Ok.into());

        SaveDialog(save_dialog)
    }

    pub fn run(&amp;self) -&gt; Option&lt;PathBuf&gt; {
        if self.0.run() == ResponseType::Ok.into() {
            self.0.get_filename()
        } else {
            None
        }
    }
}

impl Drop for OpenDialog {
    fn drop(&amp;mut self) { self.0.destroy(); }
}

impl Drop for SaveDialog {
    fn drop(&amp;mut self) { self.0.destroy(); }
}

#}</code></pre></pre>
<a class="header" href="print.html#programming-the-open-button" id="programming-the-open-button"><h1>Programming the Open Button</h1></a>
<p>Now it is time to use those dialogs to program the <strong>Open</strong>, <strong>Save</strong>, and
<strong>Save As</strong> buttons in our UI. We shall start by first implementing the
<strong>Open</strong> button by creating a new method called <strong>open_file()</strong>, which we
shall integrate within our <strong>connect_events()</strong> method.</p>
<a class="header" href="print.html#open-button" id="open-button"><h2>Open Button</h2></a>
<p>The <strong>open_file()</strong> button will obtain access to our <strong>current_file</strong>
entity, which will be updated upon successfully opening the selected
file.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
pub fn connect_events(self) -&gt; ConnectedApp {
    // External state to share across events.
    let current_file = Arc::new(RwLock::new(None));

    // Connect all of the events that this UI will act upon.
    self.editor_changed(current_file.clone(), &amp;self.header.save.clone());
    self.open_file(current_file.clone());

    // Wrap the `App` within `ConnectedApp` to enable the developer to execute the program.
    ConnectedApp(self)
}

#}</code></pre></pre>
<a class="header" href="print.html#connect_clicked" id="connect_clicked"><h3>connect_clicked()</h3></a>
<p>Now, the <strong>open_file</strong> method will simply be grabbing references to the editor's
source buffer, to write the opened file's data into the buffer; then grabbing a
reference to the web view so that we can update it after opening the file; a
reference to the header bar so that we can update the title and subtitle; and
finally the <strong>Open</strong> button itself, so that we can map the <strong>connect_clicked()</strong>
event to it.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn open_file(&amp;self, current_file: Arc&lt;RwLock&lt;Option&lt;ActiveMetadata&gt;&gt;&gt;) {
    let editor = self.content.source.buff.clone();
    let preview = self.content.preview.clone();
    let headerbar = self.header.container.clone();
    self.header.open.connect_clicked(move |_| {
        // Program the button here
    });
}

#}</code></pre></pre>
<a class="header" href="print.html#creating-an-opendialog-1" id="creating-an-opendialog-1"><h3>Creating an OpenDialog</h3></a>
<p>Within <strong>connect_clicked()</strong>, we shall start by creating a new <strong>OpenDialog</strong>.
When opening this dialog, we are to attempt to pass in the <strong>current_file</strong>'s
parent directory, if it exists, so that the open file dialog uses that
directory in the file search view by default.</p>
<blockquote>
<p>Note that I am using <strong>if let Some(ref path)</strong> rather than a <strong>map</strong>
here due to borrowing concerns -- if you can't get a map to borrow correctly,
using a <strong>match</strong> or <strong>if let</strong> usually does the trick.</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
// Create a new open file dialog using the current file's parent
// directory as the preferred directory, if it's set.
let open_dialog = OpenDialog::new({
    let lock = current_file.read().unwrap();
    if let Some(ref path) = *lock {
        path.get_dir()
    } else {
        None
    }
});

#}</code></pre></pre>
<a class="header" href="print.html#running-the-dialog" id="running-the-dialog"><h3>Running the Dialog</h3></a>
<p>Once we have our <strong>open_dialog</strong> variable, it's then just a matter of running
the dialog, grabbing the selected file path, and then handling that file
accordingly: read the file into the source buffer, update the web view,
and then update the title and subtitle.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
// Runs the dialog, and opens the file if a file was selected.
if let Some(new_file) = open_dialog.run() {
    if let Ok(mut file) = File::open(&amp;new_file) {
        // Read the file's contents into an in-memory buffer
        let mut contents = String::new();
        let _ = file.read_to_string(&amp;mut contents);

        // Update the title and subtitle
        set_title(&amp;headerbar, &amp;new_file);
        if let Some(parent) = new_file.parent() {
            let subtitle: &amp;str = &amp;parent.to_string_lossy();
            headerbar.set_subtitle(subtitle);
        }

        // Set the shared file path as this file.
        *current_file.write().unwrap() =
            Some(ActiveMetadata::new(new_file, &amp;contents.as_bytes()));

        // Update the editor &amp; preview
        editor.set_text(&amp;contents);
        preview.load_html(&amp;render(&amp;contents), None);
    }
}

#}</code></pre></pre>
<a class="header" href="print.html#the-completed-code" id="the-completed-code"><h3>The Completed Code</h3></a>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
fn open_file(&amp;self, current_file: Arc&lt;RwLock&lt;Option&lt;ActiveMetadata&gt;&gt;&gt;) {
    let editor = self.content.source.buff.clone();
    let preview = self.content.preview.clone();
    let headerbar = self.header.container.clone();
    self.header.open.connect_clicked(move |_| {
        // Create a new open file dialog using the current file's parent
        // directory as the preferred directory, if it's set.
        let open_dialog = OpenDialog::new({
            let lock = current_file.read().unwrap();
            if let Some(ref path) = *lock {
                path.get_dir()
            } else {
                None
            }
        });

        // Runs the dialog, and opens the file if a file was selected.
        if let Some(new_file) = open_dialog.run() {
            if let Ok(mut file) = File::open(&amp;new_file) {
                // Read the file's contents into an in-memory buffer
                let mut contents = String::new();
                let _ = file.read_to_string(&amp;mut contents);

                // Update the title and subtitle
                set_title(&amp;headerbar, &amp;new_file);
                if let Some(parent) = new_file.parent() {
                    let subtitle: &amp;str = &amp;parent.to_string_lossy();
                    headerbar.set_subtitle(subtitle);
                }

                // Set the shared file path as this file.
                *current_file.write().unwrap() =
                    Some(ActiveMetadata::new(new_file, &amp;contents.as_bytes()));

                // Update the editor &amp; preview
                editor.set_text(&amp;contents);
                preview.load_html(&amp;render(&amp;contents), None);
            }
        }
    });
}

#}</code></pre></pre>
<a class="header" href="print.html#programming-the-save-buttons" id="programming-the-save-buttons"><h1>Programming the Save Buttons</h1></a>
<p>The <strong>Save</strong> and <strong>Save As</strong> buttons are a bit more complicated, in part due to
the need to set the sensitivity of the <strong>Save</strong> button over time, and that the
<strong>Save</strong> button should not open a dialog when there is an active file, but
immediately save that file to the disk.</p>
<a class="header" href="print.html#appsave_event" id="appsave_event"><h2>App::save_event()</h2></a>
<p>We shall do something a bit different with the <strong>Save</strong> and <strong>Save As</strong> buttons.
We will declare a <strong>App::save_event()</strong> method we shall integrate within the
<strong>App::connect_events()</strong> method, but we will leave the implementation details
to a <strong>save()</strong> function within the <strong>save.rs</strong> module.</p>
<p>The key parameters that we need for the two dialogs is <strong>save_button</strong> that we
are going to program, the actual <strong>Save</strong> button which is named
<strong>actual_button</strong>, access to the current file's <strong>ActiveMetadata</strong>, and an
indication of whether the provided <strong>save_button</strong> is a <strong>Save As</strong> button
or not.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
// Utilized for programming the &quot;Save&quot; and &quot;Save As&quot; buttons.
fn save_event(
    &amp;self,
    save_button: &amp;Button,
    actual_button: &amp;Button,
    current_file: Arc&lt;RwLock&lt;Option&lt;ActiveMetadata&gt;&gt;&gt;,
    save_as: bool,
) {
    let editor = self.content.source.buff.clone();
    let headerbar = self.header.container.clone();
    let save_button = save_button.clone();
    actual_button.connect_clicked(
        move |_| save(&amp;editor, &amp;headerbar, &amp;save_button, &amp;current_file, save_as),
    );
}

#}</code></pre></pre>
<a class="header" href="print.html#updated-appconnect_event" id="updated-appconnect_event"><h2>Updated App::connect_event()</h2></a>
<p>In this next step, the <strong>App::connect_event()</strong> method should be written as so,
where we shall see that we have added two new method invocations to
<strong>App::save_event()</strong>. The first invocation will program the <strong>Save</strong> button,
whereas the second invocation will program the <strong>Save As</strong> button.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
/// Creates external state, and maps all of the UI functionality to the UI.
pub fn connect_events(self) -&gt; ConnectedApp {
    // External state to share across events.
    let current_file = Arc::new(RwLock::new(None));
    // Keep track of whether we are fullscreened or not.
    let fullscreen = Arc::new(AtomicBool::new(false));

    {
        let save = &amp;self.header.save;
        let save_as = &amp;self.header.save_as;

        // Connect all of the events that this UI will act upon.
        self.editor_changed(current_file.clone(), &amp;save.clone());
        self.open_file(current_file.clone());
        self.save_event(&amp;save.clone(), &amp;save.clone(), current_file.clone(), false);
        self.save_event(&amp;save, &amp;save_as, current_file.clone(), true);
    }

    // Wrap the `App` within `ConnectedApp` to enable the developer to execute the program.
    ConnectedApp(self)
}

#}</code></pre></pre>
<a class="header" href="print.html#implementing-the-savers-module" id="implementing-the-savers-module"><h2>Implementing the save.rs Module</h2></a>
<p>First we will start with the imports that this module is going to require:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
use super::SaveDialog;
use super::misc::*;
use gtk::*;
use sourceview::*;
use state::ActiveMetadata;
use std::fs::OpenOptions;
use std::io::{self, Write};
use std::sync::RwLock;

#}</code></pre></pre>
<p>Then we are going to want to know whether an action saved a new file, overwrote
the active file, or the save action was cancelled, and so we are going to create
an enum to make that distinction:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
pub enum SaveAction {
    New(ActiveMetadata),
    Saved,
    Canceled,
}

#}</code></pre></pre>
<a class="header" href="print.html#writing-data--getting-a-saveaction" id="writing-data--getting-a-saveaction"><h2>Writing Data &amp; Getting a SaveAction</h2></a>
<p>The <strong>write_data</strong> private function will be used to write the given source
buffer's <strong>data</strong> to a file, and report back with the result of the save
action. If this was the <strong>Save</strong> button and there exists a pre-existing
<strong>ActiveMetadata</strong>, then this will merely write the data to the existing
file and return an <strong>Ok(SaveAction::Saved)</strong>.</p>
<p>Otherwise, if this was the <strong>Save As</strong> button that was clicked, or the <strong>Save</strong>
button was clicked when there wasn't an active metadata stored, then a
<strong>SaveDialog</strong> will be spawned to obtain the new file and return an
<strong>Ok(SaveAction::New(ActiveMetadata))</strong>. Unless, of course, the user
happened to cancel dialog, in which case we should return an
<strong>Ok(SaveAction::Canceled)</strong>.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
/// Saves the given data to the file path supplied. If the path is **None**, a save dialog will
/// run to obtain the required path from the user. In the event that the dialog has to run to
/// obtain a file path, this function will return **Ok(Some(path))**, otherwise **Ok(None)**.
/// An **Err** value indicates an I/O-related error occurred when trying to save the file.
fn write_data(path: Option&lt;&amp;ActiveMetadata&gt;, data: &amp;[u8]) -&gt; io::Result&lt;SaveAction&gt; {
    if let Some(path) = path {
        // Save the given data to the given file, truncating the file beforehand.
        let mut file =
            OpenOptions::new().create(true).write(true).truncate(true).open(path.get_path())?;
        file.write_all(&amp;data)?;
        return Ok(SaveAction::Saved);
    }
    
    let save_dialog = SaveDialog::new(None);
    if let Some(new_path) = save_dialog.run() {
        let mut file =
            OpenOptions::new().create(true).write(true).truncate(false).open(&amp;new_path)?;
        file.write_all(data)?;
        Ok(SaveAction::New(ActiveMetadata::new(new_path, data)))
    } else {
        Ok(SaveAction::Canceled)
    }
}

#}</code></pre></pre>
<a class="header" href="print.html#writing-the-public-save-function" id="writing-the-public-save-function"><h3>Writing the Public save() Function</h3></a>
<p>Finally, we can get on to writing the public <strong>save()</strong> function within this
module. The first step will naturally be to obtain the text within the source
buffer for writing. Then we shall conditionally provide the current file's
metadata depending on whether this is the <strong>Save As</strong> button, or the <strong>Save</strong>
button. Finally, we will act upon the returned <strong>SaveAction</strong>, where a <strong>New</strong>
variant will provide the new metadata that we will store as the currently
active metadata, and to update the title and subtitle accordingly; and the
<strong>Saved</strong> action will signal that we need to get the sum for the text that
was written to the disk, and update the currently file's sum to reflect the
new state of the file.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
pub fn save(
    editor: &amp;Buffer,
    headerbar: &amp;HeaderBar,
    save: &amp;Button,
    current_file: &amp;RwLock&lt;Option&lt;ActiveMetadata&gt;&gt;,
    save_as: bool,
) {
    if let Some(text) = get_buffer(editor) {
        // If we are programming the &quot;Save As&quot; button then we will not use the
        // current path. Otherwise, we will save the editor's text to the
        // current path, if there is a current path.
        let result = if save_as {
            write_data(None, text.as_bytes())
        } else {
            write_data(current_file.read().unwrap().as_ref(), text.as_bytes())
        };

        // Now we are to match the result of the save function's output. We should
        // only act upon a return that returns an **Ok(Some(ActiveMetadata))**, setting
        // the title of the header bar, and the current file to the new path that
        // we have received.
        match result {
            Ok(SaveAction::New(file)) =&gt; {
                // Update the title and subtitle
                set_title(&amp;headerbar, file.get_path());
                if let Some(parent) = file.get_dir() {
                    let subtitle: &amp;str = &amp;parent.to_string_lossy();
                    headerbar.set_subtitle(subtitle);
                }
                let mut current_file = current_file.write().unwrap();
                *current_file = Some(file);
                save.set_sensitive(false);
            }
            Ok(SaveAction::Saved) =&gt; {
                if let Some(ref mut current_file) = *current_file.write().unwrap() {
                    current_file.set_sum(&amp;text.as_bytes());
                    save.set_sensitive(false);
                }
            }
            _ =&gt; (),
        }
    }
}

#}</code></pre></pre>
<a class="header" href="print.html#binding-keys" id="binding-keys"><h1>Binding Keys</h1></a>
<p>Finally, we are going to also program some events for when the user presses
certain keys and key combinations. In particular, to full screen the window
when the user presses <strong>F11</strong>, and to save the file when the user presses
<strong>Ctrl+S</strong>.</p>
<a class="header" href="print.html#fullscreen-state--appconnect_events-changes" id="fullscreen-state--appconnect_events-changes"><h2>Fullscreen State &amp; App::connect_events() Changes</h2></a>
<p>We are going to want to know when we should invoke either the
<strong>Window::fullscreen()</strong> or <strong>Window::unfullscreen()</strong> methods, and so it
will be important for us to store the state of the application's
fullscreen-ness within a new <strong>AtomicBool</strong> that will represent the current
state. This will be passed into our upcoming <strong>App::key_events()</strong> method,
which also will take a reference to the current file's <strong>ActiveMetadata</strong>
in order to perform operations like saving the active file.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
pub fn connect_events(self) -&gt; ConnectedApp {
    // External state to share across events.
    let current_file = Arc::new(RwLock::new(None));
    // Keep track of whether we are fullscreened or not.
    let fullscreen = Arc::new(AtomicBool::new(false));

    {
        let save = &amp;self.header.save;
        let save_as = &amp;self.header.save_as;

        // Connect all of the events that this UI will act upon.
        self.editor_changed(current_file.clone(), &amp;save.clone());
        self.open_file(current_file.clone());
        self.save_event(&amp;save.clone(), &amp;save.clone(), current_file.clone(), false);
        self.save_event(&amp;save, &amp;save_as, current_file.clone(), true);
        self.key_events(current_file, fullscreen);
    }

    // Wrap the `App` within `ConnectedApp` to enable the developer to execute the program.
    ConnectedApp(self)
}

#}</code></pre></pre>
<a class="header" href="print.html#implementing-the-appkey_events-method" id="implementing-the-appkey_events-method"><h2>Implementing the App::key_events() Method</h2></a>
<p>This is where the <strong>gdk</strong> crate immediately becomes important, as it will
help us to determine which keys have been pressed by the user, and whether
or not certain states were also enabled (such as whether Ctrl was held or
not).</p>
<p>Using the <strong>connect_key_press_event()</strong> method on the main window, we can
handle key press events that will be sent through the <strong>gdk</strong> variable
below. All you have to do is match the received state and key values, and
then execute the functionality that you want to achieve.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
/// Handles special functions that should be invoked when certain keys and key combinations
/// are pressed on the keyboard.
fn key_events(
    &amp;self,
    current_file: Arc&lt;RwLock&lt;Option&lt;ActiveMetadata&gt;&gt;&gt;,
    fullscreen: Arc&lt;AtomicBool&gt;,
) {
    // Grab required references beforehand.
    let editor = self.content.source.buff.clone();
    let headerbar = self.header.container.clone();
    let save_button = self.header.save.clone();

    // Each key press will invoke this function.
    self.window.connect_key_press_event(move |window, gdk| {
        match gdk.get_keyval() {
            // Fullscreen the UI when F11 is pressed.
            key::F11 =&gt; if fullscreen.fetch_xor(true, Ordering::SeqCst) {
                window.unfullscreen();
            } else {
                window.fullscreen();
            },
            // Save the file when ctrl+s is pressed.
            key if key == 's' as u32 &amp;&amp; gdk.get_state().contains(CONTROL_MASK) =&gt; {
                save(&amp;editor, &amp;headerbar, &amp;save_button, &amp;current_file, false);
            }
            _ =&gt; (),
        }
        Inhibit(false)
    });
}

#}</code></pre></pre>
<a class="header" href="print.html#conclusion--review-2" id="conclusion--review-2"><h1>Conclusion &amp; Review</h1></a>
<a class="header" href="print.html#mdbook-gui" id="mdbook-gui"><h1>mdBook GUI</h1></a>
<a class="header" href="print.html#list-boxes-notebooks--stacks" id="list-boxes-notebooks--stacks"><h1>List Boxes, Notebooks, &amp; Stacks</h1></a>
<a class="header" href="print.html#content-management-system" id="content-management-system"><h1>Content Management System</h1></a>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3001");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload(true); // force reload from server (not from cache)
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
    

        


        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>

<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Conclusion &amp; Review - </title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="./introduction.html"><strong>1.</strong> Introduction</a></li><li><a href="./chapter_01.html"><strong>2.</strong> Window With A Header Bar</a></li><li><a href="./chapter_02.html"><strong>3.</strong> Button Boxer</a></li><li><ul class="section"><li><a href="./chapter_02_objects.html"><strong>3.1.</strong> Boxes, Buttons, &amp; Labels</a></li><li><a href="./chapter_02_state.html"><strong>3.2.</strong> Maintaining External State</a></li><li><a href="./chapter_02_ui.html"><strong>3.3.</strong> Creating the UI Structure</a></li><li><a href="./chapter_02_programming.html"><strong>3.4.</strong> Programming the UI</a></li><li><a href="./chapter_02_review.html"><strong>3.5.</strong> Conclusion &amp; Review</a></li></ul></li><li><a href="./chapter_03.html"><strong>4.</strong> HTML Articler</a></li><li><ul class="section"><li><a href="./chapter_03_objects.html"><strong>4.1.</strong> Entries, Panes, Scrolled Windows, &amp; Text Views</a></li><li><a href="./chapter_03_horrorshow.html"><strong>4.2.</strong> Horrorshow HTML Templating</a></li><li><a href="./chapter_03_ui.html"><strong>4.3.</strong> Creating the UI Structure</a></li><li><a href="./chapter_03_programming.html"><strong>4.4.</strong> Programming the UI</a></li><li><a href="./chapter_03_review.html"><strong>4.5.</strong> Conclusion &amp; Review</a></li></ul></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="print.html#introduction--tips" id="introduction--tips"><h1>Introduction &amp; Tips</h1></a>
<p>This unofficial GTK Rust tutorial series will focus on documenting important GTK features,
demonstrating how they are used in practice, and displaying some Rusty software techniques
along the way, as we explore what GTK GUI development in Rust is like.</p>
<blockquote>
<p>This tutorial is a very early WIP, and is subject to make structural changes in the coming
weeks, until I am happy with the state of the documentation, and my own writing. If there
are any issues, please send them to my <a href="mailto:mmstickman@gmail.com">email</a>, and I will
quickly address them. The GTK API is rather extensive, so it may take a while to flesh this
out properly.</p>
</blockquote>
<a class="header" href="print.html#obtaining-the-gtk-documentation" id="obtaining-the-gtk-documentation"><h2>Obtaining the GTK documentation</h2></a>
<p>The first thing you should do is to specify the GTK features you need. The max supported
version at this time is <strong>v3_22</strong>, which looks like so in your <strong>Cargo.toml</strong> file.</p>
<pre><code class="language-toml">gtk = { version = &quot;0.2&quot;, features = [&quot;v3_22&quot;] }
</code></pre>
<p>Then you can obtain offline documentation via running the following in the terminal, within
the root directory of your Cargo project:</p>
<pre><code class="language-sh">cargo doc
</code></pre>
<p>Which will compile the documentation into <strong>target/doc/gtk/index.html</strong>.</p>
<a class="header" href="print.html#tips-regarding-navigating-the-gtk-rust-api" id="tips-regarding-navigating-the-gtk-rust-api"><h2>Tips Regarding Navigating the GTK Rust API</h2></a>
<p><img src="images/api-diagram.png" /></p>
<p>The API for GTK in Rust is not as you might expect from other Rusty APIs, and so it may seem
that there is a lot of missing functionality in the generated documentaion. Each GTK object
contains an associated <strong>ObjectExt</strong> trait, such as <strong>ButtonExt</strong>.</p>
<p><img src="images/traitext.png" /></p>
<p>They also gain access to a number of other shared traits through the <strong>IsA&lt;T&gt;</strong> wrappers,
such as <strong>IsA&lt;Container&gt;</strong>, and <strong>IsA&lt;Widget&gt;</strong>. So if you want to know all of the methods
that are available for an object, you will need to also visit the associated traits for each of
those <strong>IsA&lt;T&gt;</strong> types that are implemented, such as <strong>WidgetExt</strong>.</p>
<p><img src="images/isawrapper.png" /></p>
<a class="header" href="print.html#gtk-objects-dont-require-mutability" id="gtk-objects-dont-require-mutability"><h2>GTK Objects Don't Require Mutability</h2></a>
<p><img src="images/rust_vs_gtk.png" /></p>
<p>GTK objects have their own mechanisms of reference counting, and are designed so that
you don't require ownersip or mutable access to modify them. This simplifies things greatly,
as you will only have to worry about borrowing and ownership with native Rust types. The only
thing that you need to be aware of is that you will need to increment reference counters when
passing GTK objects into closures to program your UI, which is done by cloning the object.</p>
<a class="header" href="print.html#window-with-a-header-bar" id="window-with-a-header-bar"><h1>Window With A Header Bar</h1></a>
<p><img src="images/headerbar.png" /></p>
<p>In this chapter, we will create a simple GTK application that features a header bar. This will
serve as an introduction to the basics of creating a GTK application data structure to contain
the widgets that you will later program, as well as spawning a GTK window and running your
application.</p>
<blockquote>
<p>Before continuing, do ensure that you have added the <strong>gtk</strong> crate to your <strong>Cargo.toml</strong> file,
and additionally have specified at least <code>v3_14</code> as a feature to enable with the <strong>gtk</strong> crate.</p>
</blockquote>
<a class="header" href="print.html#creating-the-gtk-application-structures" id="creating-the-gtk-application-structures"><h2>Creating the GTK Application Structures</h2></a>
<p>The following diagram lays out how we will construct our GTK application data structure. One does
not have to follow this diagram to achieve the same result, but structuring your UI struct into a
hierarchy of partitions can be helpful to the mind.</p>
<p><img src="images/ch1_diagram.png" /></p>
<p>As we can see, we will need to create a structure that has a <strong>GtkWindow</strong> and a <strong>Header</strong>.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
extern crate gtk;
use gtk::*;
use std::process;

pub struct App {
    pub window: Window,
    pub header: Header,
}

#}</code></pre></pre>
<p>The <strong>Header</strong> is another structure that we will create, which will contain the <strong>GtkHeaderbar</strong> and
all of the widgets within that header bar.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
pub struct Header {
    pub container: HeaderBar
}

#}</code></pre></pre>
<a class="header" href="print.html#creating-the-ui-with-rust" id="creating-the-ui-with-rust"><h2>Creating the UI with Rust</h2></a>
<p>Next is to generate our UI with Rust, and store it in the newly-defined structures.</p>
<p>First is the <strong>App</strong> structure, which will be contain the overall structure of our UI in a
well-defined hierarchy of data structures and associated data. The following code example
provides in-line comments to describe each of the methods that are being used to configure it.</p>
<p>We will be creating the <strong>GtkWindow</strong> that we will attach every UI element to, the <strong>Header</strong>
structure that will contain our <strong>GtkHeaderBar</strong>, and programming the exit function within the
window. It's also important that we set a title for the window, the <strong>wmclass</strong> which will be
seen by window managers, and setting the icon to display within the window manager via the
<code>Window::set_default_icon_name()</code> function.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
impl App {
    fn new() -&gt; App {
        // Create a new top level window.
        let window = Window::new(WindowType::Toplevel);
        // Create a the headerbar and it's associated content.
        let header = Header::new();

        // Set the headerbar as the title bar widget.
        window.set_titlebar(&amp;header.container);
        // Set the title of the window.
        window.set_title(&quot;App Name&quot;);
        // Set the window manager class.
        window.set_wmclass(&quot;app-name&quot;, &quot;App name&quot;);
        // The icon the app will display.
        Window::set_default_icon_name(&quot;iconname&quot;);

        // Programs what to do when the exit button is used.
        window.connect_delete_event(move |_, _| {
            main_quit();
            Inhibit(false)
        });

        // Return our main application state
        App { window, header }
    }
}

#}</code></pre></pre>
<p>And then there is our <strong>Header</strong> structure, which for now, will only contain the <strong>GtkHeaderBar</strong>.
It is important to set the title of this header bar, if you want a title to be displayed, and to
also enable window controls on it, as this is disabled by default.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
impl Header {
    fn new() -&gt; Header {
        // Creates the main header bar container widget.
        let container = HeaderBar::new();

        // Sets the text to display in the title section of the header bar.
        container.set_title(&quot;App Name&quot;);
        // Enable the window controls within this headerbar.
        container.set_show_close_button(true);

        // Returns the header and all of it's state
        Header { container }
    }
}

#}</code></pre></pre>
<a class="header" href="print.html#initializing-and-launching-the-application" id="initializing-and-launching-the-application"><h2>Initializing and Launching the Application</h2></a>
<p>Now that we are ready, we simply need to initialize GTK, create our GTK application structure,
show all of the widgets within that structure, and start the GTK main event loop.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // Initialize GTK before proceeding.
    if gtk::init().is_err() {
        eprintln!(&quot;failed to initialize GTK Application&quot;);
        process::exit(1);
    }

    // Initialize the UI's initial state
    let app = App::new();

    // Make all the widgets within the UI visible.
    app.window.show_all();

    // Start the GTK main event loop
    gtk::main();
}
</code></pre></pre>
<p>Once the main thread has entered the event loop, it will poll across each of the widgets for
actions that have been triggered, such as the <code>connect_delete_event()</code> method that we used
above to program the exit button to exit the program.</p>
<a class="header" href="print.html#the-result" id="the-result"><h2>The Result</h2></a>
<p>With all of this complete, you should now have a program up and running that looks like so.</p>
<p><img src="images/headerbar.png" /></p>
<a class="header" href="print.html#button-boxer" id="button-boxer"><h1>Button Boxer</h1></a>
<p><img src="images/ch02_complete.png" /></p>
<p>This section will give a look into how to structure your UI with boxes, manipulate labels,
and programming clicked buttons with closures. By the end, you will also have an understanding
of how to add children to a header bar, add style classes to buttons, manage application state
via <strong>Arc</strong>'d atomic components, and align widgets within a container.</p>
<blockquote>
<p>Recall that each GTK object that you obtain from the <strong>gtk</strong> crates are wrapped so that you
need not worry about Rust borrowing rules. GTK objects are reference-counted, so when you need
to share a GTK object across multiple closures, you can do so by simply cloning a new
reference.</p>
</blockquote>
<a class="header" href="print.html#prerequisites" id="prerequisites"><h2>Prerequisites</h2></a>
<p>It is generally assumed that you have an understanding of atomics and atomic reference
counters (<strong>Arc</strong>) before continuing with this tutorial. In order to share state across multiple
programmable closures, or even multiple threads, it is vital to take advantage of these concepts.
See the <strong>std::sync</strong> and <strong>std::sync::atomic</strong> modules to learn about them beforehand. You can
also check out <a href="https://assets.bitbashing.io/papers/lockless.pdf">this paper on lockless concurrency</a>.</p>
<a class="header" href="print.html#boxes-buttons--labels" id="boxes-buttons--labels"><h1>Boxes, Buttons, &amp; Labels</h1></a>
<p>The purpose of this section is to give an explanation of the objects that are about to used,
before demonstrating how they are used in practice in subsequent sections.</p>
<a class="header" href="print.html#gtkbox" id="gtkbox"><h2>GtkBox</h2></a>
<p>A <strong>GtkBox</strong> is effectively a UI equivalent of vectors in Rust, and must be defined with an
<strong>Orientation</strong>, which defines whether elements should be aligned from left to right, or
top to bottom. For those who have experience with modern HTML5/CSS3 designs, a <strong>GtkBox</strong>
is equivalent to a flex box -- they expand to cover the full space, and widgets contained
within are expanded according to rules applied when packing the children.</p>
<a class="header" href="print.html#creating-boxes" id="creating-boxes"><h3>Creating Boxes</h3></a>
<p>In the following example, a horizontal and vertical box will be created with 0 padding between
children contained within the box. Once you have created your box, you can assign widgets to
the box using the <code>pack_*</code> methods.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let padding_between_children = 0;
let horizontal_box = Box::new(Orientation::Horizontal, padding_between_children);
let vertical_box = Box::new(Orientation::Vertical, padding_between_children);

#}</code></pre></pre>
<a class="header" href="print.html#packing-boxes" id="packing-boxes"><h3>Packing Boxes</h3></a>
<p>You may notice that the <code>pack_*</code> methods take a lot of miscellanious parameters. The first
parameter should be a reference to the widget that you are adding to the container. The
second and third parameters define the expand a fill parameters respectively. The final
parameter then defines how many units of space should be between children in the box.</p>
<blockquote>
<p>To further elaborate on the expand and fill parameters, expand defines whether the
given widget should attempt to use all of the extra space that it can. Each widget that has
the expand parameter set will equally share that extra space. Meanwhile, fill defines whether
the extra spaced should actually have that widget fill to cover that extra space, or should
merely use that extra space as padding.</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
health_info.pack_start(&amp;health_label, false, false, 5);
health_info.pack_start(&amp;health, true, true, 5);

#}</code></pre></pre>
<a class="header" href="print.html#gtklabel" id="gtklabel"><h2>GtkLabel</h2></a>
<p>A <strong>GtkLabel</strong> is simply a widget that consists solely of text. It's fairly self-explanatory
as a result. All you truly need to memorize is how to create a label, and change a label.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let information_label = Label::new(&quot;Specific Information: &quot;);
let value = Label::new(&quot;Linux&quot;);
value.set_label(&quot;Redox&quot;);

let horizontal_box = Box::new(Orientation::Horizontal, 5);
horizontal_box.pack_start(&amp;information_label, false, false, 0);
horizontal_box.pack_start(&amp;value, true, false, 0);

#}</code></pre></pre>
<a class="header" href="print.html#gtkbutton" id="gtkbutton"><h2>GtkButton</h2></a>
<a class="header" href="print.html#creating-buttons" id="creating-buttons"><h3>Creating Buttons</h3></a>
<p>A <strong>GtkButton</strong> is a simple button that contains a text label, and/or an image to represent
the action that is to be performed upon clicking that button.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let text_button = Button::new_with_label(&quot;Ok&quot;);
let image_button = Button::new_from_icon_name(&quot;icon-name&quot;, 32);

#}</code></pre></pre>
<a class="header" href="print.html#styling-buttons" id="styling-buttons"><h3>Styling Buttons</h3></a>
<p>Widgets within GTK can be styled so that they stand out from other widgets in the UI. Buttons
in particularl support two style classes: destructive-action, and suggested-action. If you have
a critical button that needs to stand out in the UI, you can set them like so:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
// Add the corresponding style classes to those buttons.
delete_button.get_style_context().map(|c| c.add_class(&quot;destructive-action&quot;));
new_button.get_style_context().map(|c| c.add_class(&quot;suggested-action&quot;));

#}</code></pre></pre>
<p>Each <strong>GtkWidget</strong> provides a <strong>get_style_context()</strong> method, which returns an
<strong>Option<StyleContext></strong>, which thereby provides an <strong>add_class()</strong> method, which is then used
to set style classes. Got it? Good. The most important classes to know for buttons are the
<code>destructive-action</code> and <code>suggested-action</code> buttons. Typically, a destructive action sets the
button to a red color, while the suggested action uses a blue color. The actual color will depend
upon which GTK theme that the user is using, though.</p>
<a class="header" href="print.html#maintaining-external-state" id="maintaining-external-state"><h1>Maintaining External State</h1></a>
<p>In this chapter, we are going to have some state that we will manipulate with the UI. We
therefore need a means of storing and loading values from that state. The program that
we are going to create has a single component: a health value.</p>
<p>As it turns out, we can take advantage of atomic primitives directly, such as
<strong>AtomicUsize</strong>, to store this value for sharing across multiple immutable closures. This
atomic value can be manipulated without requiring mutable access to the inner value. So this
can be passed around through an immutable borrow, and modified while being immutably borrowed
at multiple locations.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
pub struct HealthComponent(AtomicUsize);

#}</code></pre></pre>
<p>While we are at it, we can go ahead and abstract some logic to this component by implementing
some useful methods for initializing the health, subtracting health, and healing health.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
impl HealthComponent {
    fn new(initial: usize) -&gt; HealthComponent { HealthComponent(AtomicUsize::new(initial)) }

    fn get_health(&amp;self) -&gt; usize { self.0.load(Ordering::SeqCst) }

    fn subtract(&amp;self, value: usize) -&gt; usize {
        let current = self.0.load(Ordering::SeqCst);
        let new = if current &lt; value { 0 } else { current - value };
        self.0.store(new, Ordering::SeqCst);
        new
    }

    fn heal(&amp;self, value: usize) -&gt; usize {
        let original = self.0.fetch_add(value, Ordering::SeqCst);
        original + value
    }
}

#}</code></pre></pre>
<a class="header" href="print.html#creating-the-ui-structure" id="creating-the-ui-structure"><h1>Creating the UI Structure</h1></a>
<p>Using the previous chapter's structure as a template, we can expand that to include the new UI
elements that we are going to use within our program. It is important to note that you only
need to store elements that you are going to later program after the UI is constructed.</p>
<p>In this program, we are going to add two <strong>GtkButtons</strong> to the header bar, along with using
a vertical and horizontal <strong>GtkBox</strong> with some labels to display information about our
application's state. The following chart is the new diagram of our structure.</p>
<p><img src="images/ch02_diagram.png" /></p>
<p>Which translates to the following Rust data structures:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
pub struct App {
    pub window:  Window,
    pub header:  Header,
    pub content: Content,
}

pub struct Header {
    pub container: HeaderBar,
    pub hit:       Button,
    pub heal:      Button,
}

pub struct Content {
    pub container: Box,
    pub health:    Label,
    pub message:   Label,
}

#}</code></pre></pre>
<a class="header" href="print.html#creating-the-app-structure" id="creating-the-app-structure"><h2>Creating the App Structure</h2></a>
<p>Starting with our <strong>App</strong> structure, we will do as the last tutorial, but our <strong>new()</strong> metheod
shall take a <strong>&amp;HealthComponent</strong> as an input to set the initial value in the UI, later on
down the road within our <strong>Content</strong> structure. One will note that we have added a new
<strong>content</strong> variable of type <strong>Context</strong>, which takes that health reference.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
impl App {
    fn new(health: &amp;HealthComponent) -&gt; App {
        // Create a new top level window.
        let window = Window::new(WindowType::Toplevel);
        // Create a the headerbar and it's associated content.
        let header = Header::new();
        // Contains the content within the window.
        let content = Content::new(health);

        // Set the headerbar as the title bar widget.
        window.set_titlebar(&amp;header.container);
        // Set the title of the window.
        window.set_title(&quot;App Name&quot;);
        // Set the window manager class.
        window.set_wmclass(&quot;app-name&quot;, &quot;App name&quot;);
        // The icon the app will display.
        Window::set_default_icon_name(&quot;iconname&quot;);
        // Add the content box into the window.
        window.add(&amp;content.container);

        // Programs what to do when the exit button is used.
        window.connect_delete_event(move |_, _| {
            main_quit();
            Inhibit(false)
        });

        // Return our main application state
        App { window, header, content }
    }
}

#}</code></pre></pre>
<a class="header" href="print.html#creating-the-header" id="creating-the-header"><h2>Creating the Header</h2></a>
<p>Then we shall also implement the same method for our header, which shall now contain two
<strong>GtkButtons</strong> -- the hit and heal buttons. Also take note that we are assigning some style
classes to these buttons, to give them a more informative visual flair.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
impl Header {
    fn new() -&gt; Header {
        // Creates the main header bar container widget.
        let container = HeaderBar::new();

        // Sets the text to display in the title section of the header bar.
        container.set_title(&quot;App Name&quot;);
        // Enable the window controls within this headerbar.
        container.set_show_close_button(true);

        // Create the hit and heal buttons.
        let hit = Button::new_with_label(&quot;Hit&quot;);
        let heal = Button::new_with_label(&quot;Heal&quot;);

        // Add the corresponding style classes to those buttons.
        hit.get_style_context().map(|c| c.add_class(&quot;destructive-action&quot;));
        heal.get_style_context().map(|c| c.add_class(&quot;suggested-action&quot;));

        // THen add them to the header bar.
        container.pack_start(&amp;hit);
        container.pack_end(&amp;heal);

        // Returns the header and all of it's state
        Header { container, hit, heal }
    }
}

#}</code></pre></pre>
<a class="header" href="print.html#creating-the-content" id="creating-the-content"><h2>Creating the Content</h2></a>
<p>Now it's time to create the content for our window. You will almost reach for <strong>GtkBoxes</strong> when
constructing your UI, creating your interface with a tree-like diagram. These boxes, when initialized,
must be specified as either <strong>Horizontal</strong> or <strong>Vertical</strong> orientations.</p>
<p>You will amost certainly reach for <strong>GtkBoxes</strong>
for configuring your UI. These can be created with either a <strong>Horizontal</strong> or <strong>Vertical</strong>
alignment. These boxes are where you will add all of your widgets, where they will be stacked
according to the alignment of the box they are attached to.</p>
<p>We shall create a vertical box that will contain two children: a vertical <strong>GtkBox</strong> that contains
a label and a value, followed by a simple <strong>GtkLabel</strong> underneath.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
impl Content {
    fn new(health: &amp;HealthComponent) -&gt; Content {
        // Create a vertical box to store all of it's inner children vertically.
        let container = Box::new(Orientation::Vertical, 0);

        // The health info will be contained within a horizontal box within the vertical box.
        let health_info = Box::new(Orientation::Horizontal, 0);
        let health_label = Label::new(&quot;Current Health:&quot;);
        let health = Label::new(health.get_health().to_string().as_str());

        // Set the horizontal alignments of each of our objects.
        health_info.set_halign(Align::Center);
        health_label.set_halign(Align::Start);
        health.set_halign(Align::Start);


        // Add the health info box's children
        health_info.pack_start(&amp;health_label, false, false, 5);
        health_info.pack_start(&amp;health, true, true, 5);

        // Create a message label that will later be modified by the application, upon
        // performing a hit or heal action.
        let message = Label::new(&quot;Hello&quot;);

        // Add everything to our vertical box
        container.pack_start(&amp;health_info, true, false, 0);
        container.pack_start(&amp;Separator::new(Orientation::Horizontal), false, false, 0);
        container.pack_start(&amp;message, true, false, 0);

        Content { container, health, message }
    }
}

#}</code></pre></pre>
<a class="header" href="print.html#set-alignments" id="set-alignments"><h3>Set Alignments</h3></a>
<p>You may have noticed that the above code is setting horizontal alignments. Widgets can optionally
be supplied an alignment enum to their <code>set_halign()</code> and <code>set_valign()</code> methods, which, as you
would guess, modifies the alignment of the child within the UI.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
// Set the horizontal alignments of each of our objects.
health_info.set_halign(Align::Center);
health_label.set_halign(Align::Start);
health.set_halign(Align::Start);

#}</code></pre></pre>
<a class="header" href="print.html#programming-the-ui" id="programming-the-ui"><h1>Programming the UI</h1></a>
<p>At this point, we can now wire everything together in the main thread. First we will set the
default value (health value) for the state of the program. That value will be used to set
the initial state of the GTK application structure. Then we shall program the hit and heal
buttons, which shall change values in the content area of main window.</p>
<a class="header" href="print.html#before-we-start" id="before-we-start"><h2>Before We Start</h2></a>
<p>We are going to have some predefined strings utilized based on what action was performed, and
certain conditions of the <strong>HealthComponents</strong> value. To do this, we will have a <strong>MESSAGES</strong>
array that we will access via a <strong>u8</strong>-sized enum, which will be used to get indexes into the
array.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
/// Predefined messages that will be used by the UI upon certain conditions.
const MESSAGES: [&amp;str; 3] = [&quot;Ouch! You hit me!&quot;, &quot;...&quot;, &quot;Thanks!&quot;];

#[repr(u8)]
// An enum, represented as a u8, that is used as an index into the `MESSAGES` array.
enum Message { Hit, Dead, Heal }

#}</code></pre></pre>
<p>For those not yet versed in Rust, the <code>#[repr(u8)]</code> attribute defines that the following item
should be represented as a <strong>u8</strong> value in memory. By default, enum variants start counting from
zero, so <strong>Hit</strong> is <code>0</code>, whereas <strong>Heal</strong> is <code>2</code>. If you want to make this explicit, you can also
write this as so:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
#[repr(u8)]
enum Message { Hit = 0, Dead = 1, Heal = 2 }

#}</code></pre></pre>
<a class="header" href="print.html#initializing-the-health-component--application-structure" id="initializing-the-health-component--application-structure"><h2>Initializing the Health Component &amp; Application Structure</h2></a>
<p>After initializing GTK, we will create our health component, which will be wrapped within an
atomic reference-counted pointer (<strong>Arc</strong>). If we remember from previous code, the inner value
is actually an <strong>AtomicUsize</strong>, which serves as our health counter. This value will be shared
among multiple closures, hence the requirement for the reference counter.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let health = Arc::new(HealthComponent::new(10));

#}</code></pre></pre>
<p>Using this value, we will create our application's UI structure. Note that <code>&amp;health</code> is
automatically referenced as an <strong>&amp;HealthComponent</strong>, even though it's wrapped within an <strong>Arc</strong>.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let app = App::new(&amp;health);

#}</code></pre></pre>
<a class="header" href="print.html#programming-the-hit-button" id="programming-the-hit-button"><h2>Programming the Hit Button</h2></a>
<p>From here on, all we need to is to program our widgets, and this is where we will share both
our health component, and various other UI widgets across closures. Starting with the hit button,
we simply need to program what will happen when that button is clicked. The <strong>ButtonExt</strong> trait
provides a <strong>connect_clicked()</strong> method for precisely that.</p>
<blockquote>
<p>Note that widgets in GTK typically pass themselves through their closures, so if you need to
manipulate the calling widget, you can do so by using the assigned value passed through the
closure. We don't require this functionality, so we shall ignore the value.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
widget.connect_action(move |widget| {});

#}</code></pre></pre>
</blockquote>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
{
    // Program the Hit button to subtract health.
    let health = health.clone();
    let message = app.content.message.clone();
    let info = app.content.health.clone();
    app.header.hit.clone().connect_clicked(move |_| {
        let new_health = health.subtract(1);
        let action = if new_health == 0 { Message::Dead } else { Message::Hit };
        message.set_label(MESSAGES[action as usize]);
        info.set_label(new_health.to_string().as_str());
    });
}

#}</code></pre></pre>
<p>In the above, we create an anonymous scope so that we can self-contain our cloned references.
Each invocation of <strong>clone()</strong> will simply increment a reference counter, and enable these values
to be used again at a later time.</p>
<p>After subtracting from the health component, if the health is now <code>0</code>, we will return
<strong>Message::Dead</strong>, otherwise the message shall be <strong>MessageHit</strong>. Once we have this information,
it's just a matter of updated the labels with their new values.</p>
<a class="header" href="print.html#programming-the-heal-button" id="programming-the-heal-button"><h2>Programming the Heal Button</h2></a>
<p>This works almost identically, so we can effectively copy and paste the above code, and then
modify it to meet our needs for this action.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
{
    // Program the Heal button to restore health.
    let health = health.clone();
    let message = app.content.message.clone();
    let info = app.content.health.clone();
    app.header.heal.clone().connect_clicked(move |_| {
        let new_health = health.heal(5);
        message.set_label(MESSAGES[Message::Heal as usize]);
        info.set_label(new_health.to_string().as_str());
    });
}

#}</code></pre></pre>
<a class="header" href="print.html#altogether" id="altogether"><h2>Altogether</h2></a>
<p>After programming the UI, you can end the code by tacking on the following at the end:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
// Make all the widgets within the UI visible.
app.window.show_all();

// Start the GTK main event loop
gtk::main();

#}</code></pre></pre>
<p>And you should have your source code look as follows:</p>
<pre><pre class="playpen"><code class="language-rust">/// Predefined messages that will be used by the UI upon certain conditions.
const MESSAGES: [&amp;str; 3] = [&quot;Ouch! You hit me!&quot;, &quot;...&quot;, &quot;Thanks!&quot;];

#[repr(u8)]
// An enum, used as a u8, that is used as an index into the `MESSAGES` array.
enum Message { Hit, Dead, Heal }

fn main() {
    // Initialize GTK before proceeding.
    if gtk::init().is_err() {
        eprintln!(&quot;failed to initialize GTK Application&quot;);
        process::exit(1);
    }

    // Set the initial state of our health component. We use an `Arc` so that we can share
    // this value across multiple programmable closures.
    let health = Arc::new(HealthComponent::new(10));

    // Initialize the UI's initial state.
    let app = App::new(&amp;health);

    {
        // Program the Hit button to subtract health.
        let health = health.clone();
        let message = app.content.message.clone();
        let info = app.content.health.clone();
        app.header.hit.clone().connect_clicked(move |_| {
            let new_health = health.subtract(1);
            let action = if new_health == 0 { Message::Dead } else { Message::Hit };
            message.set_label(MESSAGES[action as usize]);
            info.set_label(new_health.to_string().as_str());
        });
    }

    {
        // Program the Heal button to restore health.
        let health = health.clone();
        let message = app.content.message.clone();
        let info = app.content.health.clone();
        app.header.heal.clone().connect_clicked(move |_| {
            let new_health = health.heal(5);
            message.set_label(MESSAGES[Message::Heal as usize]);
            info.set_label(new_health.to_string().as_str());
        });
    }

    // Make all the widgets within the UI visible.
    app.window.show_all();

    // Start the GTK main event loop
    gtk::main();
}
</code></pre></pre>
<a class="header" href="print.html#conclusion--review" id="conclusion--review"><h1>Conclusion &amp; Review</h1></a>
<p>If you click on the <strong>Hit</strong> button, the counter should decrement and the message should change.
Clicking on the <strong>Heal</strong> button should increment the counter and also change the message.After
running your program with <code>cargo run</code>, you should have a window that looks like so:</p>
<p><img src="images/ch02_complete.png"></p>
<p>At this point, you should have a decent understanding of how <strong>GtkBox</strong>, <strong>GtkButton</strong>, and
<strong>GtkLabel</strong> works. It may be a good idea to revisit the previons
<a href="./chapter_02_objects.md">GTK Objects Covered</a> section to review the specific details regarding
them.</p>
<a class="header" href="print.html#practice-challenges" id="practice-challenges"><h2>Practice Challenges</h2></a>
<a class="header" href="print.html#setting-inputs-w-buttons" id="setting-inputs-w-buttons"><h3>Setting Inputs w/ Buttons</h3></a>
<p>There isn't much that you can do with just buttons and labels. If you want a practice challenge,
try creating a program that displays a simple random math problem, and asks the user to use
buttons to set the value. If they get it correct, modify a label to tell the user that what they
entered was correct. This is an incredibly annoying interface design, so don't do this in the real
world!</p>
<a class="header" href="print.html#bonus-timed-answers" id="bonus-timed-answers"><h3>Bonus: Timed Answers</h3></a>
<p>Do the same as the above, but also take advantage of
<a href="https://docs.rs/gtk/0.2.0/gtk/fn.timeout_add.html">gtk::timeout_add()</a> to decrement
and update a timer label within the UI until the timer reaches zero.</p>
<a class="header" href="print.html#html-articler" id="html-articler"><h1>HTML Articler</h1></a>
<p><img src="images/ch03_complete.png" /></p>
<p>In this chapter, you will begin to write useful software that takes advantage of text entries
and text views, to allow the user to enter data within various input fields, and to generate
an output from those inputs after clicking a button. In addition, you will also be exposed
to the '<strong>html!</strong>' macro within the <a href="https://docs.rs/horrorshow/">horrorshow crate</a>.
You will be writing a program that takes inputs on the left pane, and generates minified HTML
within the right text view.</p>
<blockquote>
<p>Note that there isn't any external state to worry about in this chapter, as there was in the
last. All of the state that we are concerned with is contained within the GTK objects that
we will be interacting with.</p>
</blockquote>
<a class="header" href="print.html#entries-panes-scrolled-windows--text-views" id="entries-panes-scrolled-windows--text-views"><h1>Entries, Panes, Scrolled Windows, &amp; Text Views</h1></a>
<a class="header" href="print.html#gtkpaned" id="gtkpaned"><h2>GtkPaned</h2></a>
<p>These are containers that may be oriented either vertically or horizontally, and feature two
resizeable children. These children are resized merely by clicking and dragging the divider
between them.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let container = Paned::new(Orientation::Horizontal);
let left_widget = ...;
let right_widget = ...;
container.pack1(&amp;left_widget, true, true);
container.pack2(&amp;right_widget, true, true);

#}</code></pre></pre>
<p>Within the pack methods above, the two <code>true</code> values designate whether the child can shrink,
and whether the child can be resized.</p>
<a class="header" href="print.html#gtkentry" id="gtkentry"><h2>GtkEntry</h2></a>
<p>Entries enable the UI to accept a line of text as input, which can be utilized by other widgets
to perform certain actions using that text as the input.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let entry = Entry::new();
entry.set_text(&quot;Some Text&quot;);
if let Some(text) = entry.get_text() {
    println!(&quot;{}&quot;, text);
}

#}</code></pre></pre>
<a class="header" href="print.html#gtktextview" id="gtktextview"><h2>GtkTextView</h2></a>
<p>Text views serve two purposes: the ability to display multiple lines of text within a text box,
and the ability to input multiple lines of text. These may be configured to be non-editable,
if editing a view is not desired. They also provide methods for controlling the word-wrapping
behavior. They aren't capable of handling formatted text, however, or useful as a code editor.
If you want text to be rendered in HTML, see <strong>GtkWebView</strong>; and if you want a code editor, see
<strong>GtkSourceView</strong>.</p>
<blockquote>
<p>Note that it is often times best to create and assign the <strong>GtkTextBuffer</strong> to your text view
manually, in order to get a handle to that buffer which you can store, and avoid some
indirection when programming your UI, and to get direct access to the text within.</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
// The buffer for the text view, with `None` as the parameter because we are
// not going to define any text tags for this buffer.
let text_buffer = TextBuffer::new(None);
// Then we shall assign the buffer to a new text view, which will automatically
// update itself as text is added or removed from the buffer.
let text_view = TextView::new_with_buffer(&amp;text_buffer);

#}</code></pre></pre>
<p>Getting text from a <strong>GtkTextBuffer</strong> is a little tricky, so here's an abstraction which you
can use to specify to grab the entire range of the buffer and return it as a <strong>String</strong>. As it
turns out, you may specify a specific range of text to obtain from this buffer.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
/// Obtain the entire text buffer's contents as a string.
fn get_buffer(buffer: &amp;TextBuffer) -&gt; Option&lt;String&gt; {
    let start = buffer.get_start_iter();
    let end = buffer.get_end_iter();
    buffer.get_text(&amp;start, &amp;end, true)
}

#}</code></pre></pre>
<a class="header" href="print.html#gtkscrolledwindow" id="gtkscrolledwindow"><h2>GtkScrolledWindow</h2></a>
<p>These are single-element boxes that feature a scrollable window within. It can be useful to combine
them with text views to enable text views to scroll. This is precisely what we are about to do
within this chapter.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let scrolled_window = ScrolledWindow::new(None, None);
scrolled_window.add(&amp;text_view);

#}</code></pre></pre>
<a class="header" href="print.html#horrorshow-html-templating" id="horrorshow-html-templating"><h1>Horrorshow HTML Templating</h1></a>
<p>Although not related to GTK development, the <a href="docs.rs/horrorshow/">horrorshow crate</a> provides
very useful macro-based HTML templating capabilities, which allows you to efficiently generate
an HTML string in memory using a DSL (domain-specific language) combined with Rust, which can
be invoked through usage of the <code>@</code> sigil.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
#[macro_use]
extern crate horrorshow;
use horrorshow::helper::doctype;

let title = &quot;Title&quot;;
let content = &quot;A string\nwith multiple\n\nlines&quot;;
let html_string = format!(
    &quot;{}&quot;,
    html!{
        : doctype::HTML,
        html {
            head {
                style { : &quot;#style { }&quot; }
            }
            body {
                h1(id=&quot;style&quot;) { : title }
                @ for line in content.lines().filter(|x| !x.is_empty()) {
                    p { : line }
                }
            }
        }
    }
);

#}</code></pre></pre>
<a class="header" href="print.html#creating-the-ui-structure-1" id="creating-the-ui-structure-1"><h1>Creating the UI Structure</h1></a>
<p><img src="images/ch03_complete.png" /></p>
<p>Using the first chapter as a template and expanding upon that, we shall design our UI according
to the vision of our UI, pictured above. The key widgets to take note of are the <strong>post</strong> button
in the header bar; and within our content window is a <strong>title</strong> entry, <strong>tags</strong> entry,
<strong>content</strong> text view, and a <strong>right_pane</strong> text view for displaying the output in HTML. As such,
our application's UI structure should look as so:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
pub struct App {
    pub window: Window,
    pub header: Header,
    pub content: Content,
}

pub struct Header {
    pub container: HeaderBar,
    pub post: Button
}

pub struct Content {
    pub container: Paned,
    pub title: Entry,
    pub tags: Entry,
    pub content: TextBuffer,
    pub right_pane: TextBuffer,
}

#}</code></pre></pre>
<p>Note that the container for our content will not be a <strong>GtkBox</strong>, but a <strong>GtkPaned</strong>. This will
enable the user to drag the divider between the panels to resize them as needed. In addition,
the <strong>content</strong> and <strong>right_pane</strong> fields are stored as <strong>GtkTextBuffers</strong>, instead of
<strong>GtkTextViews</strong>. This is because we are not going to be programming the views -- just accessing
the underlying text buffers that are associated with the views.</p>
<a class="header" href="print.html#app-implementation" id="app-implementation"><h2>App Implementation</h2></a>
<p>Something new that we will do here is to define the default size of the window, as we should
have a reasonable size for the user to interact with by default, without needing to resize
the window to get a good look at the contents within. We are also setting the title of this
application as 'HTML Articler'. Beyond that, this should be very similar for every application
you develop.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
impl App {
    fn new() -&gt; App {
        // Create a new top level window.
        let window = Window::new(WindowType::Toplevel);
        // Create a the headerbar and it's associated content.
        let header = Header::new();
        // Create the main content.
        let content = Content::new();

        // Set the headerbar as the title bar widget.
        window.set_titlebar(&amp;header.container);
        // Set the title of the window.
        window.set_title(&quot;HTML Articler&quot;);
        // Set the window manager class.
        window.set_wmclass(&quot;html-articler&quot;, &quot;HTML Articler&quot;);
        // The icon the app will display.
        Window::set_default_icon_name(&quot;iconname&quot;);
        // Set the default size of the window.
        window.set_default_size(800, 600);
        // Add the content to the window.
        window.add(&amp;content.container);

        // Programs what to do when the exit button is used.
        window.connect_delete_event(move |_, _| {
            main_quit();
            Inhibit(false)
        });

        // Return our main application state
        App { window, header, content }
    }
}

#}</code></pre></pre>
<a class="header" href="print.html#header-implementation" id="header-implementation"><h2>Header Implementation</h2></a>
<p>Our header bar will simply have a button with a &quot;Post&quot; label, which is given a 'suggested-action'
as a style class, and packed at the end of the bar. The title of the bar should also be set to
the name of our application.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
impl Header {
    fn new() -&gt; Header {
        // Creates the main header bar container widget.
        let container = HeaderBar::new();

        // Sets the text to display in the title section of the header bar.
        container.set_title(&quot;HTML Articler&quot;);
        // Enable the window controls within this headerbar.
        container.set_show_close_button(true);

        // Create a button that will post the HTML article.
        let post = Button::new_with_label(&quot;Post&quot;);
        post.get_style_context().map(|x| x.add_class(&quot;suggested-action&quot;));

        container.pack_end(&amp;post);

        // Returns the header and all of it's state
        Header { container, post }
    }
}

#}</code></pre></pre>
<a class="header" href="print.html#content-implementation" id="content-implementation"><h2>Content Implementation</h2></a>
<p>This is where we will spend most of our time for this application. First we create a
<strong>GtkPaned</strong> container that will hold our resizeable left and right panes. Our right pane
will be a <strong>GtkTextView</strong>, whereas the left pane is a vertical <strong>GtkBox</strong>. Note that we
are interested in getting direct access to that text view's buffer, so we will also
initialize that before creating the view. The left pane's box will have a padding of <code>5</code>
between children, just so that they aren't smushed together.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
// The main container will hold a left and right pane. The left pane is for user input,
// whereas the right pane is for the generated output.
let container = Paned::new(Orientation::Horizontal);
let left_pane = Box::new(Orientation::Vertical, 5);
let right_pane = TextBuffer::new(None);
let right_pane_view = TextView::new_with_buffer(&amp;right_pane);

#}</code></pre></pre>
<p>Then comes creating the <strong>title</strong> and <strong>tags</strong> entries, as well as the <strong>content</strong> view that
we will use to construct the left pane.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
// The left pane will consist of a title entry, tags entry, and content text view.
let title = Entry::new();
let tags = Entry::new();
let content = TextBuffer::new(None);
let content_view = TextView::new_with_buffer(&amp;content);

#}</code></pre></pre>
<p>Note that we will also be storing a centered label above the <strong>content</strong> text view, followed
by adding some placeholder text within the entries, and tooltips to display when a mouse is
hovering over the entries.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
// The label that we will display above the content box to describe it.
let content_label = Label::new(&quot;Content&quot;);
content_label.set_halign(Align::Center);

// Set placeholders within the entries to hint the user of the contents to enter.
title.set_placeholder_text(&quot;Insert Title&quot;);
tags.set_placeholder_text(&quot;Insert Colon-Delimited Tags&quot;);

// Additionally set tooltips on the entries. Note that you may use either text or markup.
title.set_tooltip_text(&quot;Insert the title of article here&quot;);
tags.set_tooltip_markup(&quot;&lt;b&gt;tag_one&lt;/b&gt;:&lt;b&gt;tag two&lt;/b&gt;:&lt;b&gt; tag three&lt;/b&gt;&quot;);

#}</code></pre></pre>
<p>Then ensuring that the right pane's text view is not editable, and both of the text views
have their text wrapped by words.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
// The right pane should disallow editing; and both editors should wrap by word.
right_pane_view.set_editable(false);
right_pane_view.set_wrap_mode(WrapMode::Word);
content_view.set_wrap_mode(WrapMode::Word);

#}</code></pre></pre>
<p>Now we just need to wrap the text views within some <strong>GtkScrolledWindows</strong> to enable the user
to scroll through the text, in the event that there is enough text that it cannot be displayed
all at once within the widget.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
// Wrap the text views within scrolled windows, so that they can scroll.
let content_scroller = ScrolledWindow::new(None, None);
let right_pane_scrolled = ScrolledWindow::new(None, None);
content_scroller.add(&amp;content_view);
right_pane_scrolled.add(&amp;right_pane_view);

#}</code></pre></pre>
<p>And to make our UI look better, we can apply some borders and margins accordingly.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
// Paddin' Widgets
left_pane.set_border_width(5);
right_pane_view.set_left_margin(5);
right_pane_view.set_right_margin(5);
right_pane_view.set_top_margin(5);
right_pane_view.set_bottom_margin(5);
content_view.set_left_margin(5);
content_view.set_right_margin(5);
content_view.set_top_margin(5);
content_view.set_bottom_margin(5);

#}</code></pre></pre>
<p>And all that remains is to pack our widgets into their panes and return a <strong>Content</strong> structure.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
// First add everything to the left pane box.
left_pane.pack_start(&amp;title, false, true, 0);
left_pane.pack_start(&amp;tags, false, true, 0);
left_pane.pack_start(&amp;content_label, false, false, 0);
left_pane.pack_start(&amp;content_scroller, true, true, 0);

// Then add the left and right panes into the container
container.pack1(&amp;left_pane, true, true);
container.pack2(&amp;right_pane_scrolled, true, true);

Content { container, title, tags, content, right_pane }

#}</code></pre></pre>
<p>Put it all together, and you should have an implementation that looks as follows:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
impl Content {
    fn new() -&gt; Content {
        // The main container will hold a left and right pane. The left pane is for user input,
        // whereas the right pane is for the generated output.
        let container = Paned::new(Orientation::Horizontal);
        let left_pane = Box::new(Orientation::Vertical, 5);
        let right_pane = TextBuffer::new(None);
        let right_pane_view = TextView::new_with_buffer(&amp;right_pane);

        // The left pane will consist of a title entry, tags entry, and content text view.
        let title = Entry::new();
        let tags = Entry::new();
        let content = TextBuffer::new(None);
        let content_view = TextView::new_with_buffer(&amp;content);

        // The label that we will display above the content box to describe it.
        let content_label = Label::new(&quot;Content&quot;);
        content_label.set_halign(Align::Center);

        // Set placeholders within the entries to hint the user of the contents to enter.
        title.set_placeholder_text(&quot;Insert Title&quot;);
        tags.set_placeholder_text(&quot;Insert Colon-Delimited Tags&quot;);

        // Additionally set tooltips on the entries. Note that you may use either text or markup.
        title.set_tooltip_text(&quot;Insert the title of article here&quot;);
        tags.set_tooltip_markup(&quot;&lt;b&gt;tag_one&lt;/b&gt;:&lt;b&gt;tag two&lt;/b&gt;:&lt;b&gt; tag three&lt;/b&gt;&quot;);

        // The right pane should disallow editing; and both editors should wrap by word.
        right_pane_view.set_editable(false);
        right_pane_view.set_wrap_mode(WrapMode::Word);
        content_view.set_wrap_mode(WrapMode::Word);

        // Wrap the text views within scrolled windows, so that they can scroll.
        let content_scroller = ScrolledWindow::new(None, None);
        let right_pane_scrolled = ScrolledWindow::new(None, None);
        content_scroller.add(&amp;content_view);
        right_pane_scrolled.add(&amp;right_pane_view);

        // Paddin' Widgets
        left_pane.set_border_width(5);
        right_pane_view.set_left_margin(5);
        right_pane_view.set_right_margin(5);
        right_pane_view.set_top_margin(5);
        right_pane_view.set_bottom_margin(5);
        content_view.set_left_margin(5);
        content_view.set_right_margin(5);
        content_view.set_top_margin(5);
        content_view.set_bottom_margin(5);

        // First add everything to the left pane box.
        left_pane.pack_start(&amp;title, false, true, 0);
        left_pane.pack_start(&amp;tags, false, true, 0);
        left_pane.pack_start(&amp;content_label, false, false, 0);
        left_pane.pack_start(&amp;content_scroller, true, true, 0);

        // Then add the left and right panes into the container
        container.pack1(&amp;left_pane, true, true);
        container.pack2(&amp;right_pane_scrolled, true, true);

        Content { container, title, tags, content, right_pane }
    }
}

#}</code></pre></pre>
<a class="header" href="print.html#programming-the-ui-1" id="programming-the-ui-1"><h1>Programming the UI</h1></a>
<p>So, with all the widgets that are going to interact with each other, you might think that this
part will be a tiny bit difficult to implement. Well, if you think that, you're completely
wrong, as this will actually be the easiest part of the program to implement! Starting with
chapter 1's main function as a template, which looks like so:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // Initialize GTK before proceeding.
    if gtk::init().is_err() {
        eprintln!(&quot;failed to initialize GTK Application&quot;);
        process::exit(1);
    }

    // Initialize the UI's initial state
    let app = App::new();

    // Program your widgets here!

    // Make all the widgets within the UI visible.
    app.window.show_all();

    // Start the GTK main event loop
    gtk::main();
}
</code></pre></pre>
<p>We are going to program the <strong>Post button</strong> to take the <strong>title</strong> and <strong>tags</strong> entries, as well
as the <strong>content</strong> text view's buffer, pass the strings from these widgets directly through
a horrorshow HTML macro, and write the output into the <strong>right_pane's</strong> text buffer. The code for
programming the button will look as follows:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
{
    // Program the post button to take the inputs in the left pane, and update HTML code
    // within the right pane accordingly. Prepared to increment reference counters...
    let title = app.content.title.clone();
    let tags = app.content.tags.clone();
    let content = app.content.content.clone();
    let right_pane = app.content.right_pane.clone();
    app.header.post.connect_clicked(move |_| {
        let inputs = (title.get_text(), tags.get_text(), get_buffer(&amp;content));
        if let (Some(title), Some(tags), Some(content)) = inputs {
            right_pane.set_text(&amp;generate_html(&amp;title, &amp;tags, &amp;content));
        }
    });
}

#}</code></pre></pre>
<p>Note that obtaining the text from an entry is very straightforward. All it takes is to invoke the
<strong>get_text()</strong> method, which returns an <strong>Option&lt;String&gt;</strong>. Getting text from a text buffer is
slightly more difficult, so you will need to use the abstraction that was recommended at the
beginning of this chapter. This function is written as so:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
/// Obtain the entire text buffer's contents as a string.
fn get_buffer(buffer: &amp;TextBuffer) -&gt; Option&lt;String&gt; {
    let start = buffer.get_start_iter();
    let end = buffer.get_end_iter();
    buffer.get_text(&amp;start, &amp;end, true)
}

#}</code></pre></pre>
<p>You will also notice this interesting pattern in Rust that has majorly simplified things for us
when obtaining each of the inputs, to collectively check if all inputs have an input before
attempting to do anything with the inputs. The <strong>if let</strong> syntax in Rust works on more than just
patterns, but tuples as well, so you may check multiple values within a tuple at the same time,
just as you would in a <strong>match</strong>.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
let inputs = (title.get_text(), tags.get_text(), get_buffer(&amp;content));
if let (Some(title), Some(tags), Some(content)) = inputs {
    right_pane.set_text(&amp;generate_html(&amp;title, &amp;tags, &amp;content));
}

#}</code></pre></pre>
<p>Althugh we have yet to define our <strong>generate_html</strong> function, and this will be the final
component for implementing this application. The simplest way to use the <strong>html!</strong> macro is to
use it as an argument within the <strong>format!</strong> macro. And so, our function will look as so,
although you are free to implement the HTML macro however you like.</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_variables)]
#fn main() {
/// Generates the minified HTML that will be displayed in the right pane
fn generate_html(title: &amp;str, tags: &amp;str, content: &amp;str) -&gt; String {
    format!{
        &quot;{}&quot;,
        html!{
            article {
                header {
                    h1 { : &amp;title }
                    div(class=&quot;tags&quot;) {
                        @ for tag in tags.split(':') {
                            div(class=&quot;tag&quot;) { : tag }
                        }
                    }
                }
                @ for line in content.lines().filter(|x| !x.is_empty()) {
                    p { : line }
                }
            }
        }
    }
}

#}</code></pre></pre>
<p>The above syntax should be fairly readable. We create a pair of <strong>article</strong> tags, which contain
a both a pair of <strong>header</strong> tags, and and a <strong>p</strong> paragraph for each non-empty line of input that
was obtained from the <strong>content</strong> text buffer. Within the <strong>header</strong> tags is a <strong>h1</strong> header that
is defined to use the title entry as the text within, and a <strong>div</strong> that contains a list of tags,
delimited by colons.</p>
<p><img src="images/ch03_complete.png" /></p>
<p>With all this in place, you should have a fully functioning program that looks like the original
picture.</p>
<a class="header" href="print.html#conclusion--review-1" id="conclusion--review-1"><h1>Conclusion &amp; Review</h1></a>
<p><img src="images/ch03_complete.png" /></p>
<p>At this point, you should begin to have a good understanding of how to write GTK
applications with Rust. At this point, you should know how to do the following:</p>
<ul>
<li>Creating, getting, and assigning values to <strong>Labels</strong></li>
<li>Creating, getting, and assigning values to <strong>Entries</strong></li>
<li>Creating, getting, and assigning values to <strong>TextBuffers</strong></li>
<li>Creating and assigning buffers to <strong>TextViews</strong></li>
<li>Creating, styling, and program <strong>Buttons</strong></li>
<li>Assign widgets to <strong>Boxes</strong> and <strong>Paned</strong> containers</li>
<li>Set paddings and margins on widgets</li>
<li>Maintaining External States</li>
</ul>
<a class="header" href="print.html#practice-challenges-1" id="practice-challenges-1"><h2>Practice Challenges</h2></a>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3001");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload(true); // force reload from server (not from cache)
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
    

        


        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
